
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Simulation
 * 
 */
export type Simulation = $Result.DefaultSelection<Prisma.$SimulationPayload>
/**
 * Model SimulationStep
 * 
 */
export type SimulationStep = $Result.DefaultSelection<Prisma.$SimulationStepPayload>
/**
 * Model Rubric
 * 
 */
export type Rubric = $Result.DefaultSelection<Prisma.$RubricPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model UserSimulation
 * 
 */
export type UserSimulation = $Result.DefaultSelection<Prisma.$UserSimulationPayload>
/**
 * Model Submission
 * 
 */
export type Submission = $Result.DefaultSelection<Prisma.$SubmissionPayload>
/**
 * Model Analytics
 * 
 */
export type Analytics = $Result.DefaultSelection<Prisma.$AnalyticsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  EMPLOYER: 'EMPLOYER',
  CANDIDATE: 'CANDIDATE',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const StepType: {
  AI_CHAT: 'AI_CHAT',
  CODE_REVIEW: 'CODE_REVIEW',
  DOCUMENT_ANALYSIS: 'DOCUMENT_ANALYSIS',
  MULTIPLE_CHOICE: 'MULTIPLE_CHOICE'
};

export type StepType = (typeof StepType)[keyof typeof StepType]


export const InviteStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED'
};

export type InviteStatus = (typeof InviteStatus)[keyof typeof InviteStatus]


export const SimulationStatus: {
  INVITED: 'INVITED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED'
};

export type SimulationStatus = (typeof SimulationStatus)[keyof typeof SimulationStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type StepType = $Enums.StepType

export const StepType: typeof $Enums.StepType

export type InviteStatus = $Enums.InviteStatus

export const InviteStatus: typeof $Enums.InviteStatus

export type SimulationStatus = $Enums.SimulationStatus

export const SimulationStatus: typeof $Enums.SimulationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.simulation`: Exposes CRUD operations for the **Simulation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Simulations
    * const simulations = await prisma.simulation.findMany()
    * ```
    */
  get simulation(): Prisma.SimulationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.simulationStep`: Exposes CRUD operations for the **SimulationStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimulationSteps
    * const simulationSteps = await prisma.simulationStep.findMany()
    * ```
    */
  get simulationStep(): Prisma.SimulationStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rubric`: Exposes CRUD operations for the **Rubric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rubrics
    * const rubrics = await prisma.rubric.findMany()
    * ```
    */
  get rubric(): Prisma.RubricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSimulation`: Exposes CRUD operations for the **UserSimulation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSimulations
    * const userSimulations = await prisma.userSimulation.findMany()
    * ```
    */
  get userSimulation(): Prisma.UserSimulationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **Submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submissions
    * const submissions = await prisma.submission.findMany()
    * ```
    */
  get submission(): Prisma.SubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analytics`: Exposes CRUD operations for the **Analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analytics
    * const analytics = await prisma.analytics.findMany()
    * ```
    */
  get analytics(): Prisma.AnalyticsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Simulation: 'Simulation',
    SimulationStep: 'SimulationStep',
    Rubric: 'Rubric',
    Invitation: 'Invitation',
    UserSimulation: 'UserSimulation',
    Submission: 'Submission',
    Analytics: 'Analytics'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "simulation" | "simulationStep" | "rubric" | "invitation" | "userSimulation" | "submission" | "analytics"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Simulation: {
        payload: Prisma.$SimulationPayload<ExtArgs>
        fields: Prisma.SimulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          findFirst: {
            args: Prisma.SimulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          findMany: {
            args: Prisma.SimulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>[]
          }
          create: {
            args: Prisma.SimulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          createMany: {
            args: Prisma.SimulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>[]
          }
          delete: {
            args: Prisma.SimulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          update: {
            args: Prisma.SimulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          deleteMany: {
            args: Prisma.SimulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SimulationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>[]
          }
          upsert: {
            args: Prisma.SimulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          aggregate: {
            args: Prisma.SimulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulation>
          }
          groupBy: {
            args: Prisma.SimulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationCountAggregateOutputType> | number
          }
        }
      }
      SimulationStep: {
        payload: Prisma.$SimulationStepPayload<ExtArgs>
        fields: Prisma.SimulationStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload>
          }
          findFirst: {
            args: Prisma.SimulationStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload>
          }
          findMany: {
            args: Prisma.SimulationStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload>[]
          }
          create: {
            args: Prisma.SimulationStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload>
          }
          createMany: {
            args: Prisma.SimulationStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload>[]
          }
          delete: {
            args: Prisma.SimulationStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload>
          }
          update: {
            args: Prisma.SimulationStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload>
          }
          deleteMany: {
            args: Prisma.SimulationStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SimulationStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload>[]
          }
          upsert: {
            args: Prisma.SimulationStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationStepPayload>
          }
          aggregate: {
            args: Prisma.SimulationStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulationStep>
          }
          groupBy: {
            args: Prisma.SimulationStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationStepCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationStepCountAggregateOutputType> | number
          }
        }
      }
      Rubric: {
        payload: Prisma.$RubricPayload<ExtArgs>
        fields: Prisma.RubricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RubricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RubricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload>
          }
          findFirst: {
            args: Prisma.RubricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RubricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload>
          }
          findMany: {
            args: Prisma.RubricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload>[]
          }
          create: {
            args: Prisma.RubricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload>
          }
          createMany: {
            args: Prisma.RubricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RubricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload>[]
          }
          delete: {
            args: Prisma.RubricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload>
          }
          update: {
            args: Prisma.RubricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload>
          }
          deleteMany: {
            args: Prisma.RubricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RubricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RubricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload>[]
          }
          upsert: {
            args: Prisma.RubricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubricPayload>
          }
          aggregate: {
            args: Prisma.RubricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRubric>
          }
          groupBy: {
            args: Prisma.RubricGroupByArgs<ExtArgs>
            result: $Utils.Optional<RubricGroupByOutputType>[]
          }
          count: {
            args: Prisma.RubricCountArgs<ExtArgs>
            result: $Utils.Optional<RubricCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      UserSimulation: {
        payload: Prisma.$UserSimulationPayload<ExtArgs>
        fields: Prisma.UserSimulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSimulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSimulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload>
          }
          findFirst: {
            args: Prisma.UserSimulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSimulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload>
          }
          findMany: {
            args: Prisma.UserSimulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload>[]
          }
          create: {
            args: Prisma.UserSimulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload>
          }
          createMany: {
            args: Prisma.UserSimulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSimulationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload>[]
          }
          delete: {
            args: Prisma.UserSimulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload>
          }
          update: {
            args: Prisma.UserSimulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload>
          }
          deleteMany: {
            args: Prisma.UserSimulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSimulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSimulationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload>[]
          }
          upsert: {
            args: Prisma.UserSimulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSimulationPayload>
          }
          aggregate: {
            args: Prisma.UserSimulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSimulation>
          }
          groupBy: {
            args: Prisma.UserSimulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSimulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSimulationCountArgs<ExtArgs>
            result: $Utils.Optional<UserSimulationCountAggregateOutputType> | number
          }
        }
      }
      Submission: {
        payload: Prisma.$SubmissionPayload<ExtArgs>
        fields: Prisma.SubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findFirst: {
            args: Prisma.SubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findMany: {
            args: Prisma.SubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          create: {
            args: Prisma.SubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          createMany: {
            args: Prisma.SubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          delete: {
            args: Prisma.SubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          update: {
            args: Prisma.SubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          deleteMany: {
            args: Prisma.SubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          upsert: {
            args: Prisma.SubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          aggregate: {
            args: Prisma.SubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmission>
          }
          groupBy: {
            args: Prisma.SubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<SubmissionCountAggregateOutputType> | number
          }
        }
      }
      Analytics: {
        payload: Prisma.$AnalyticsPayload<ExtArgs>
        fields: Prisma.AnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findMany: {
            args: Prisma.AnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          create: {
            args: Prisma.AnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          createMany: {
            args: Prisma.AnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          update: {
            args: Prisma.AnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalytics>
          }
          groupBy: {
            args: Prisma.AnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    simulation?: SimulationOmit
    simulationStep?: SimulationStepOmit
    rubric?: RubricOmit
    invitation?: InvitationOmit
    userSimulation?: UserSimulationOmit
    submission?: SubmissionOmit
    analytics?: AnalyticsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdSimulations: number
    simulations: number
    submissions: number
    invitations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdSimulations?: boolean | UserCountOutputTypeCountCreatedSimulationsArgs
    simulations?: boolean | UserCountOutputTypeCountSimulationsArgs
    submissions?: boolean | UserCountOutputTypeCountSubmissionsArgs
    invitations?: boolean | UserCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSimulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSimulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSimulationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * Count Type SimulationCountOutputType
   */

  export type SimulationCountOutputType = {
    steps: number
    invitations: number
    submissions: number
    userSimulations: number
    analytics: number
  }

  export type SimulationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | SimulationCountOutputTypeCountStepsArgs
    invitations?: boolean | SimulationCountOutputTypeCountInvitationsArgs
    submissions?: boolean | SimulationCountOutputTypeCountSubmissionsArgs
    userSimulations?: boolean | SimulationCountOutputTypeCountUserSimulationsArgs
    analytics?: boolean | SimulationCountOutputTypeCountAnalyticsArgs
  }

  // Custom InputTypes
  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationCountOutputType
     */
    select?: SimulationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationStepWhereInput
  }

  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
  }

  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeCountUserSimulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSimulationWhereInput
  }

  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
  }


  /**
   * Count Type SimulationStepCountOutputType
   */

  export type SimulationStepCountOutputType = {
    submissions: number
  }

  export type SimulationStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | SimulationStepCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * SimulationStepCountOutputType without action
   */
  export type SimulationStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStepCountOutputType
     */
    select?: SimulationStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SimulationStepCountOutputType without action
   */
  export type SimulationStepCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    firstName: string | null
    lastName: string | null
    company: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    firstName: string | null
    lastName: string | null
    company: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    firstName: number
    lastName: number
    company: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    firstName?: true
    lastName?: true
    company?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    firstName?: true
    lastName?: true
    company?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    firstName?: true
    lastName?: true
    company?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    role: $Enums.UserRole
    firstName: string | null
    lastName: string | null
    company: string | null
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdSimulations?: boolean | User$createdSimulationsArgs<ExtArgs>
    simulations?: boolean | User$simulationsArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "firstName" | "lastName" | "company" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdSimulations?: boolean | User$createdSimulationsArgs<ExtArgs>
    simulations?: boolean | User$simulationsArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdSimulations: Prisma.$SimulationPayload<ExtArgs>[]
      simulations: Prisma.$UserSimulationPayload<ExtArgs>[]
      submissions: Prisma.$SubmissionPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      role: $Enums.UserRole
      firstName: string | null
      lastName: string | null
      company: string | null
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdSimulations<T extends User$createdSimulationsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSimulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    simulations<T extends User$simulationsArgs<ExtArgs> = {}>(args?: Subset<T, User$simulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends User$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends User$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly company: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.createdSimulations
   */
  export type User$createdSimulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    where?: SimulationWhereInput
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    cursor?: SimulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * User.simulations
   */
  export type User$simulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    where?: UserSimulationWhereInput
    orderBy?: UserSimulationOrderByWithRelationInput | UserSimulationOrderByWithRelationInput[]
    cursor?: UserSimulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSimulationScalarFieldEnum | UserSimulationScalarFieldEnum[]
  }

  /**
   * User.submissions
   */
  export type User$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    cursor?: SubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * User.invitations
   */
  export type User$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Simulation
   */

  export type AggregateSimulation = {
    _count: SimulationCountAggregateOutputType | null
    _avg: SimulationAvgAggregateOutputType | null
    _sum: SimulationSumAggregateOutputType | null
    _min: SimulationMinAggregateOutputType | null
    _max: SimulationMaxAggregateOutputType | null
  }

  export type SimulationAvgAggregateOutputType = {
    duration: number | null
  }

  export type SimulationSumAggregateOutputType = {
    duration: number | null
  }

  export type SimulationMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    duration: number | null
    isPublished: boolean | null
    isBlindMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    employerId: string | null
  }

  export type SimulationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    duration: number | null
    isPublished: boolean | null
    isBlindMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    employerId: string | null
  }

  export type SimulationCountAggregateOutputType = {
    id: number
    title: number
    description: number
    duration: number
    isPublished: number
    isBlindMode: number
    createdAt: number
    updatedAt: number
    employerId: number
    _all: number
  }


  export type SimulationAvgAggregateInputType = {
    duration?: true
  }

  export type SimulationSumAggregateInputType = {
    duration?: true
  }

  export type SimulationMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    duration?: true
    isPublished?: true
    isBlindMode?: true
    createdAt?: true
    updatedAt?: true
    employerId?: true
  }

  export type SimulationMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    duration?: true
    isPublished?: true
    isBlindMode?: true
    createdAt?: true
    updatedAt?: true
    employerId?: true
  }

  export type SimulationCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    duration?: true
    isPublished?: true
    isBlindMode?: true
    createdAt?: true
    updatedAt?: true
    employerId?: true
    _all?: true
  }

  export type SimulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Simulation to aggregate.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Simulations
    **/
    _count?: true | SimulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SimulationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SimulationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationMaxAggregateInputType
  }

  export type GetSimulationAggregateType<T extends SimulationAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulation[P]>
      : GetScalarType<T[P], AggregateSimulation[P]>
  }




  export type SimulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationWhereInput
    orderBy?: SimulationOrderByWithAggregationInput | SimulationOrderByWithAggregationInput[]
    by: SimulationScalarFieldEnum[] | SimulationScalarFieldEnum
    having?: SimulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationCountAggregateInputType | true
    _avg?: SimulationAvgAggregateInputType
    _sum?: SimulationSumAggregateInputType
    _min?: SimulationMinAggregateInputType
    _max?: SimulationMaxAggregateInputType
  }

  export type SimulationGroupByOutputType = {
    id: string
    title: string
    description: string | null
    duration: number
    isPublished: boolean
    isBlindMode: boolean
    createdAt: Date
    updatedAt: Date
    employerId: string
    _count: SimulationCountAggregateOutputType | null
    _avg: SimulationAvgAggregateOutputType | null
    _sum: SimulationSumAggregateOutputType | null
    _min: SimulationMinAggregateOutputType | null
    _max: SimulationMaxAggregateOutputType | null
  }

  type GetSimulationGroupByPayload<T extends SimulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationGroupByOutputType[P]>
        }
      >
    >


  export type SimulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    duration?: boolean
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employerId?: boolean
    employer?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | Simulation$stepsArgs<ExtArgs>
    invitations?: boolean | Simulation$invitationsArgs<ExtArgs>
    submissions?: boolean | Simulation$submissionsArgs<ExtArgs>
    rubric?: boolean | Simulation$rubricArgs<ExtArgs>
    userSimulations?: boolean | Simulation$userSimulationsArgs<ExtArgs>
    analytics?: boolean | Simulation$analyticsArgs<ExtArgs>
    _count?: boolean | SimulationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulation"]>

  export type SimulationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    duration?: boolean
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employerId?: boolean
    employer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulation"]>

  export type SimulationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    duration?: boolean
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employerId?: boolean
    employer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulation"]>

  export type SimulationSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    duration?: boolean
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employerId?: boolean
  }

  export type SimulationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "duration" | "isPublished" | "isBlindMode" | "createdAt" | "updatedAt" | "employerId", ExtArgs["result"]["simulation"]>
  export type SimulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employer?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | Simulation$stepsArgs<ExtArgs>
    invitations?: boolean | Simulation$invitationsArgs<ExtArgs>
    submissions?: boolean | Simulation$submissionsArgs<ExtArgs>
    rubric?: boolean | Simulation$rubricArgs<ExtArgs>
    userSimulations?: boolean | Simulation$userSimulationsArgs<ExtArgs>
    analytics?: boolean | Simulation$analyticsArgs<ExtArgs>
    _count?: boolean | SimulationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SimulationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SimulationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SimulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Simulation"
    objects: {
      employer: Prisma.$UserPayload<ExtArgs>
      steps: Prisma.$SimulationStepPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
      submissions: Prisma.$SubmissionPayload<ExtArgs>[]
      rubric: Prisma.$RubricPayload<ExtArgs> | null
      userSimulations: Prisma.$UserSimulationPayload<ExtArgs>[]
      analytics: Prisma.$AnalyticsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      duration: number
      isPublished: boolean
      isBlindMode: boolean
      createdAt: Date
      updatedAt: Date
      employerId: string
    }, ExtArgs["result"]["simulation"]>
    composites: {}
  }

  type SimulationGetPayload<S extends boolean | null | undefined | SimulationDefaultArgs> = $Result.GetResult<Prisma.$SimulationPayload, S>

  type SimulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SimulationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SimulationCountAggregateInputType | true
    }

  export interface SimulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Simulation'], meta: { name: 'Simulation' } }
    /**
     * Find zero or one Simulation that matches the filter.
     * @param {SimulationFindUniqueArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationFindUniqueArgs>(args: SelectSubset<T, SimulationFindUniqueArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Simulation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SimulationFindUniqueOrThrowArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Simulation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationFindFirstArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationFindFirstArgs>(args?: SelectSubset<T, SimulationFindFirstArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Simulation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationFindFirstOrThrowArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Simulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Simulations
     * const simulations = await prisma.simulation.findMany()
     * 
     * // Get first 10 Simulations
     * const simulations = await prisma.simulation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationWithIdOnly = await prisma.simulation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationFindManyArgs>(args?: SelectSubset<T, SimulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Simulation.
     * @param {SimulationCreateArgs} args - Arguments to create a Simulation.
     * @example
     * // Create one Simulation
     * const Simulation = await prisma.simulation.create({
     *   data: {
     *     // ... data to create a Simulation
     *   }
     * })
     * 
     */
    create<T extends SimulationCreateArgs>(args: SelectSubset<T, SimulationCreateArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Simulations.
     * @param {SimulationCreateManyArgs} args - Arguments to create many Simulations.
     * @example
     * // Create many Simulations
     * const simulation = await prisma.simulation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationCreateManyArgs>(args?: SelectSubset<T, SimulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Simulations and returns the data saved in the database.
     * @param {SimulationCreateManyAndReturnArgs} args - Arguments to create many Simulations.
     * @example
     * // Create many Simulations
     * const simulation = await prisma.simulation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Simulations and only return the `id`
     * const simulationWithIdOnly = await prisma.simulation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Simulation.
     * @param {SimulationDeleteArgs} args - Arguments to delete one Simulation.
     * @example
     * // Delete one Simulation
     * const Simulation = await prisma.simulation.delete({
     *   where: {
     *     // ... filter to delete one Simulation
     *   }
     * })
     * 
     */
    delete<T extends SimulationDeleteArgs>(args: SelectSubset<T, SimulationDeleteArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Simulation.
     * @param {SimulationUpdateArgs} args - Arguments to update one Simulation.
     * @example
     * // Update one Simulation
     * const simulation = await prisma.simulation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationUpdateArgs>(args: SelectSubset<T, SimulationUpdateArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Simulations.
     * @param {SimulationDeleteManyArgs} args - Arguments to filter Simulations to delete.
     * @example
     * // Delete a few Simulations
     * const { count } = await prisma.simulation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationDeleteManyArgs>(args?: SelectSubset<T, SimulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Simulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Simulations
     * const simulation = await prisma.simulation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationUpdateManyArgs>(args: SelectSubset<T, SimulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Simulations and returns the data updated in the database.
     * @param {SimulationUpdateManyAndReturnArgs} args - Arguments to update many Simulations.
     * @example
     * // Update many Simulations
     * const simulation = await prisma.simulation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Simulations and only return the `id`
     * const simulationWithIdOnly = await prisma.simulation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SimulationUpdateManyAndReturnArgs>(args: SelectSubset<T, SimulationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Simulation.
     * @param {SimulationUpsertArgs} args - Arguments to update or create a Simulation.
     * @example
     * // Update or create a Simulation
     * const simulation = await prisma.simulation.upsert({
     *   create: {
     *     // ... data to create a Simulation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Simulation we want to update
     *   }
     * })
     */
    upsert<T extends SimulationUpsertArgs>(args: SelectSubset<T, SimulationUpsertArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Simulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationCountArgs} args - Arguments to filter Simulations to count.
     * @example
     * // Count the number of Simulations
     * const count = await prisma.simulation.count({
     *   where: {
     *     // ... the filter for the Simulations we want to count
     *   }
     * })
    **/
    count<T extends SimulationCountArgs>(
      args?: Subset<T, SimulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Simulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationAggregateArgs>(args: Subset<T, SimulationAggregateArgs>): Prisma.PrismaPromise<GetSimulationAggregateType<T>>

    /**
     * Group by Simulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationGroupByArgs['orderBy'] }
        : { orderBy?: SimulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Simulation model
   */
  readonly fields: SimulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Simulation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    steps<T extends Simulation$stepsArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Simulation$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends Simulation$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rubric<T extends Simulation$rubricArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$rubricArgs<ExtArgs>>): Prisma__RubricClient<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userSimulations<T extends Simulation$userSimulationsArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$userSimulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analytics<T extends Simulation$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Simulation model
   */
  interface SimulationFieldRefs {
    readonly id: FieldRef<"Simulation", 'String'>
    readonly title: FieldRef<"Simulation", 'String'>
    readonly description: FieldRef<"Simulation", 'String'>
    readonly duration: FieldRef<"Simulation", 'Int'>
    readonly isPublished: FieldRef<"Simulation", 'Boolean'>
    readonly isBlindMode: FieldRef<"Simulation", 'Boolean'>
    readonly createdAt: FieldRef<"Simulation", 'DateTime'>
    readonly updatedAt: FieldRef<"Simulation", 'DateTime'>
    readonly employerId: FieldRef<"Simulation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Simulation findUnique
   */
  export type SimulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation findUniqueOrThrow
   */
  export type SimulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation findFirst
   */
  export type SimulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Simulations.
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Simulations.
     */
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * Simulation findFirstOrThrow
   */
  export type SimulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Simulations.
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Simulations.
     */
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * Simulation findMany
   */
  export type SimulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulations to fetch.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Simulations.
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * Simulation create
   */
  export type SimulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * The data needed to create a Simulation.
     */
    data: XOR<SimulationCreateInput, SimulationUncheckedCreateInput>
  }

  /**
   * Simulation createMany
   */
  export type SimulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Simulations.
     */
    data: SimulationCreateManyInput | SimulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Simulation createManyAndReturn
   */
  export type SimulationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * The data used to create many Simulations.
     */
    data: SimulationCreateManyInput | SimulationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Simulation update
   */
  export type SimulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * The data needed to update a Simulation.
     */
    data: XOR<SimulationUpdateInput, SimulationUncheckedUpdateInput>
    /**
     * Choose, which Simulation to update.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation updateMany
   */
  export type SimulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Simulations.
     */
    data: XOR<SimulationUpdateManyMutationInput, SimulationUncheckedUpdateManyInput>
    /**
     * Filter which Simulations to update
     */
    where?: SimulationWhereInput
    /**
     * Limit how many Simulations to update.
     */
    limit?: number
  }

  /**
   * Simulation updateManyAndReturn
   */
  export type SimulationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * The data used to update Simulations.
     */
    data: XOR<SimulationUpdateManyMutationInput, SimulationUncheckedUpdateManyInput>
    /**
     * Filter which Simulations to update
     */
    where?: SimulationWhereInput
    /**
     * Limit how many Simulations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Simulation upsert
   */
  export type SimulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * The filter to search for the Simulation to update in case it exists.
     */
    where: SimulationWhereUniqueInput
    /**
     * In case the Simulation found by the `where` argument doesn't exist, create a new Simulation with this data.
     */
    create: XOR<SimulationCreateInput, SimulationUncheckedCreateInput>
    /**
     * In case the Simulation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationUpdateInput, SimulationUncheckedUpdateInput>
  }

  /**
   * Simulation delete
   */
  export type SimulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter which Simulation to delete.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation deleteMany
   */
  export type SimulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Simulations to delete
     */
    where?: SimulationWhereInput
    /**
     * Limit how many Simulations to delete.
     */
    limit?: number
  }

  /**
   * Simulation.steps
   */
  export type Simulation$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    where?: SimulationStepWhereInput
    orderBy?: SimulationStepOrderByWithRelationInput | SimulationStepOrderByWithRelationInput[]
    cursor?: SimulationStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationStepScalarFieldEnum | SimulationStepScalarFieldEnum[]
  }

  /**
   * Simulation.invitations
   */
  export type Simulation$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Simulation.submissions
   */
  export type Simulation$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    cursor?: SubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Simulation.rubric
   */
  export type Simulation$rubricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    where?: RubricWhereInput
  }

  /**
   * Simulation.userSimulations
   */
  export type Simulation$userSimulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    where?: UserSimulationWhereInput
    orderBy?: UserSimulationOrderByWithRelationInput | UserSimulationOrderByWithRelationInput[]
    cursor?: UserSimulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSimulationScalarFieldEnum | UserSimulationScalarFieldEnum[]
  }

  /**
   * Simulation.analytics
   */
  export type Simulation$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    cursor?: AnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Simulation without action
   */
  export type SimulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
  }


  /**
   * Model SimulationStep
   */

  export type AggregateSimulationStep = {
    _count: SimulationStepCountAggregateOutputType | null
    _avg: SimulationStepAvgAggregateOutputType | null
    _sum: SimulationStepSumAggregateOutputType | null
    _min: SimulationStepMinAggregateOutputType | null
    _max: SimulationStepMaxAggregateOutputType | null
  }

  export type SimulationStepAvgAggregateOutputType = {
    order: number | null
  }

  export type SimulationStepSumAggregateOutputType = {
    order: number | null
  }

  export type SimulationStepMinAggregateOutputType = {
    id: string | null
    simulationId: string | null
    type: $Enums.StepType | null
    title: string | null
    instructions: string | null
    order: number | null
    aiPersona: string | null
  }

  export type SimulationStepMaxAggregateOutputType = {
    id: string | null
    simulationId: string | null
    type: $Enums.StepType | null
    title: string | null
    instructions: string | null
    order: number | null
    aiPersona: string | null
  }

  export type SimulationStepCountAggregateOutputType = {
    id: number
    simulationId: number
    type: number
    title: number
    instructions: number
    content: number
    order: number
    aiPersona: number
    expectedOutput: number
    _all: number
  }


  export type SimulationStepAvgAggregateInputType = {
    order?: true
  }

  export type SimulationStepSumAggregateInputType = {
    order?: true
  }

  export type SimulationStepMinAggregateInputType = {
    id?: true
    simulationId?: true
    type?: true
    title?: true
    instructions?: true
    order?: true
    aiPersona?: true
  }

  export type SimulationStepMaxAggregateInputType = {
    id?: true
    simulationId?: true
    type?: true
    title?: true
    instructions?: true
    order?: true
    aiPersona?: true
  }

  export type SimulationStepCountAggregateInputType = {
    id?: true
    simulationId?: true
    type?: true
    title?: true
    instructions?: true
    content?: true
    order?: true
    aiPersona?: true
    expectedOutput?: true
    _all?: true
  }

  export type SimulationStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationStep to aggregate.
     */
    where?: SimulationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationSteps to fetch.
     */
    orderBy?: SimulationStepOrderByWithRelationInput | SimulationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimulationSteps
    **/
    _count?: true | SimulationStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SimulationStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SimulationStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationStepMaxAggregateInputType
  }

  export type GetSimulationStepAggregateType<T extends SimulationStepAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulationStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulationStep[P]>
      : GetScalarType<T[P], AggregateSimulationStep[P]>
  }




  export type SimulationStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationStepWhereInput
    orderBy?: SimulationStepOrderByWithAggregationInput | SimulationStepOrderByWithAggregationInput[]
    by: SimulationStepScalarFieldEnum[] | SimulationStepScalarFieldEnum
    having?: SimulationStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationStepCountAggregateInputType | true
    _avg?: SimulationStepAvgAggregateInputType
    _sum?: SimulationStepSumAggregateInputType
    _min?: SimulationStepMinAggregateInputType
    _max?: SimulationStepMaxAggregateInputType
  }

  export type SimulationStepGroupByOutputType = {
    id: string
    simulationId: string
    type: $Enums.StepType
    title: string
    instructions: string
    content: JsonValue | null
    order: number
    aiPersona: string | null
    expectedOutput: JsonValue | null
    _count: SimulationStepCountAggregateOutputType | null
    _avg: SimulationStepAvgAggregateOutputType | null
    _sum: SimulationStepSumAggregateOutputType | null
    _min: SimulationStepMinAggregateOutputType | null
    _max: SimulationStepMaxAggregateOutputType | null
  }

  type GetSimulationStepGroupByPayload<T extends SimulationStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationStepGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationStepGroupByOutputType[P]>
        }
      >
    >


  export type SimulationStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    type?: boolean
    title?: boolean
    instructions?: boolean
    content?: boolean
    order?: boolean
    aiPersona?: boolean
    expectedOutput?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    submissions?: boolean | SimulationStep$submissionsArgs<ExtArgs>
    _count?: boolean | SimulationStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationStep"]>

  export type SimulationStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    type?: boolean
    title?: boolean
    instructions?: boolean
    content?: boolean
    order?: boolean
    aiPersona?: boolean
    expectedOutput?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationStep"]>

  export type SimulationStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    type?: boolean
    title?: boolean
    instructions?: boolean
    content?: boolean
    order?: boolean
    aiPersona?: boolean
    expectedOutput?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationStep"]>

  export type SimulationStepSelectScalar = {
    id?: boolean
    simulationId?: boolean
    type?: boolean
    title?: boolean
    instructions?: boolean
    content?: boolean
    order?: boolean
    aiPersona?: boolean
    expectedOutput?: boolean
  }

  export type SimulationStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "simulationId" | "type" | "title" | "instructions" | "content" | "order" | "aiPersona" | "expectedOutput", ExtArgs["result"]["simulationStep"]>
  export type SimulationStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    submissions?: boolean | SimulationStep$submissionsArgs<ExtArgs>
    _count?: boolean | SimulationStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SimulationStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }
  export type SimulationStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }

  export type $SimulationStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimulationStep"
    objects: {
      simulation: Prisma.$SimulationPayload<ExtArgs>
      submissions: Prisma.$SubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      simulationId: string
      type: $Enums.StepType
      title: string
      instructions: string
      content: Prisma.JsonValue | null
      order: number
      aiPersona: string | null
      expectedOutput: Prisma.JsonValue | null
    }, ExtArgs["result"]["simulationStep"]>
    composites: {}
  }

  type SimulationStepGetPayload<S extends boolean | null | undefined | SimulationStepDefaultArgs> = $Result.GetResult<Prisma.$SimulationStepPayload, S>

  type SimulationStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SimulationStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SimulationStepCountAggregateInputType | true
    }

  export interface SimulationStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimulationStep'], meta: { name: 'SimulationStep' } }
    /**
     * Find zero or one SimulationStep that matches the filter.
     * @param {SimulationStepFindUniqueArgs} args - Arguments to find a SimulationStep
     * @example
     * // Get one SimulationStep
     * const simulationStep = await prisma.simulationStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationStepFindUniqueArgs>(args: SelectSubset<T, SimulationStepFindUniqueArgs<ExtArgs>>): Prisma__SimulationStepClient<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SimulationStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SimulationStepFindUniqueOrThrowArgs} args - Arguments to find a SimulationStep
     * @example
     * // Get one SimulationStep
     * const simulationStep = await prisma.simulationStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationStepFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationStepClient<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStepFindFirstArgs} args - Arguments to find a SimulationStep
     * @example
     * // Get one SimulationStep
     * const simulationStep = await prisma.simulationStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationStepFindFirstArgs>(args?: SelectSubset<T, SimulationStepFindFirstArgs<ExtArgs>>): Prisma__SimulationStepClient<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStepFindFirstOrThrowArgs} args - Arguments to find a SimulationStep
     * @example
     * // Get one SimulationStep
     * const simulationStep = await prisma.simulationStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationStepFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationStepClient<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SimulationSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimulationSteps
     * const simulationSteps = await prisma.simulationStep.findMany()
     * 
     * // Get first 10 SimulationSteps
     * const simulationSteps = await prisma.simulationStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationStepWithIdOnly = await prisma.simulationStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationStepFindManyArgs>(args?: SelectSubset<T, SimulationStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SimulationStep.
     * @param {SimulationStepCreateArgs} args - Arguments to create a SimulationStep.
     * @example
     * // Create one SimulationStep
     * const SimulationStep = await prisma.simulationStep.create({
     *   data: {
     *     // ... data to create a SimulationStep
     *   }
     * })
     * 
     */
    create<T extends SimulationStepCreateArgs>(args: SelectSubset<T, SimulationStepCreateArgs<ExtArgs>>): Prisma__SimulationStepClient<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SimulationSteps.
     * @param {SimulationStepCreateManyArgs} args - Arguments to create many SimulationSteps.
     * @example
     * // Create many SimulationSteps
     * const simulationStep = await prisma.simulationStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationStepCreateManyArgs>(args?: SelectSubset<T, SimulationStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimulationSteps and returns the data saved in the database.
     * @param {SimulationStepCreateManyAndReturnArgs} args - Arguments to create many SimulationSteps.
     * @example
     * // Create many SimulationSteps
     * const simulationStep = await prisma.simulationStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimulationSteps and only return the `id`
     * const simulationStepWithIdOnly = await prisma.simulationStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationStepCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SimulationStep.
     * @param {SimulationStepDeleteArgs} args - Arguments to delete one SimulationStep.
     * @example
     * // Delete one SimulationStep
     * const SimulationStep = await prisma.simulationStep.delete({
     *   where: {
     *     // ... filter to delete one SimulationStep
     *   }
     * })
     * 
     */
    delete<T extends SimulationStepDeleteArgs>(args: SelectSubset<T, SimulationStepDeleteArgs<ExtArgs>>): Prisma__SimulationStepClient<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SimulationStep.
     * @param {SimulationStepUpdateArgs} args - Arguments to update one SimulationStep.
     * @example
     * // Update one SimulationStep
     * const simulationStep = await prisma.simulationStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationStepUpdateArgs>(args: SelectSubset<T, SimulationStepUpdateArgs<ExtArgs>>): Prisma__SimulationStepClient<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SimulationSteps.
     * @param {SimulationStepDeleteManyArgs} args - Arguments to filter SimulationSteps to delete.
     * @example
     * // Delete a few SimulationSteps
     * const { count } = await prisma.simulationStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationStepDeleteManyArgs>(args?: SelectSubset<T, SimulationStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimulationSteps
     * const simulationStep = await prisma.simulationStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationStepUpdateManyArgs>(args: SelectSubset<T, SimulationStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationSteps and returns the data updated in the database.
     * @param {SimulationStepUpdateManyAndReturnArgs} args - Arguments to update many SimulationSteps.
     * @example
     * // Update many SimulationSteps
     * const simulationStep = await prisma.simulationStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SimulationSteps and only return the `id`
     * const simulationStepWithIdOnly = await prisma.simulationStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SimulationStepUpdateManyAndReturnArgs>(args: SelectSubset<T, SimulationStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SimulationStep.
     * @param {SimulationStepUpsertArgs} args - Arguments to update or create a SimulationStep.
     * @example
     * // Update or create a SimulationStep
     * const simulationStep = await prisma.simulationStep.upsert({
     *   create: {
     *     // ... data to create a SimulationStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimulationStep we want to update
     *   }
     * })
     */
    upsert<T extends SimulationStepUpsertArgs>(args: SelectSubset<T, SimulationStepUpsertArgs<ExtArgs>>): Prisma__SimulationStepClient<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SimulationSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStepCountArgs} args - Arguments to filter SimulationSteps to count.
     * @example
     * // Count the number of SimulationSteps
     * const count = await prisma.simulationStep.count({
     *   where: {
     *     // ... the filter for the SimulationSteps we want to count
     *   }
     * })
    **/
    count<T extends SimulationStepCountArgs>(
      args?: Subset<T, SimulationStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimulationStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationStepAggregateArgs>(args: Subset<T, SimulationStepAggregateArgs>): Prisma.PrismaPromise<GetSimulationStepAggregateType<T>>

    /**
     * Group by SimulationStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationStepGroupByArgs['orderBy'] }
        : { orderBy?: SimulationStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimulationStep model
   */
  readonly fields: SimulationStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimulationStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    simulation<T extends SimulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationDefaultArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    submissions<T extends SimulationStep$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, SimulationStep$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimulationStep model
   */
  interface SimulationStepFieldRefs {
    readonly id: FieldRef<"SimulationStep", 'String'>
    readonly simulationId: FieldRef<"SimulationStep", 'String'>
    readonly type: FieldRef<"SimulationStep", 'StepType'>
    readonly title: FieldRef<"SimulationStep", 'String'>
    readonly instructions: FieldRef<"SimulationStep", 'String'>
    readonly content: FieldRef<"SimulationStep", 'Json'>
    readonly order: FieldRef<"SimulationStep", 'Int'>
    readonly aiPersona: FieldRef<"SimulationStep", 'String'>
    readonly expectedOutput: FieldRef<"SimulationStep", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SimulationStep findUnique
   */
  export type SimulationStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    /**
     * Filter, which SimulationStep to fetch.
     */
    where: SimulationStepWhereUniqueInput
  }

  /**
   * SimulationStep findUniqueOrThrow
   */
  export type SimulationStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    /**
     * Filter, which SimulationStep to fetch.
     */
    where: SimulationStepWhereUniqueInput
  }

  /**
   * SimulationStep findFirst
   */
  export type SimulationStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    /**
     * Filter, which SimulationStep to fetch.
     */
    where?: SimulationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationSteps to fetch.
     */
    orderBy?: SimulationStepOrderByWithRelationInput | SimulationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationSteps.
     */
    cursor?: SimulationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationSteps.
     */
    distinct?: SimulationStepScalarFieldEnum | SimulationStepScalarFieldEnum[]
  }

  /**
   * SimulationStep findFirstOrThrow
   */
  export type SimulationStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    /**
     * Filter, which SimulationStep to fetch.
     */
    where?: SimulationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationSteps to fetch.
     */
    orderBy?: SimulationStepOrderByWithRelationInput | SimulationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationSteps.
     */
    cursor?: SimulationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationSteps.
     */
    distinct?: SimulationStepScalarFieldEnum | SimulationStepScalarFieldEnum[]
  }

  /**
   * SimulationStep findMany
   */
  export type SimulationStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    /**
     * Filter, which SimulationSteps to fetch.
     */
    where?: SimulationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationSteps to fetch.
     */
    orderBy?: SimulationStepOrderByWithRelationInput | SimulationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimulationSteps.
     */
    cursor?: SimulationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationSteps.
     */
    skip?: number
    distinct?: SimulationStepScalarFieldEnum | SimulationStepScalarFieldEnum[]
  }

  /**
   * SimulationStep create
   */
  export type SimulationStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    /**
     * The data needed to create a SimulationStep.
     */
    data: XOR<SimulationStepCreateInput, SimulationStepUncheckedCreateInput>
  }

  /**
   * SimulationStep createMany
   */
  export type SimulationStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimulationSteps.
     */
    data: SimulationStepCreateManyInput | SimulationStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimulationStep createManyAndReturn
   */
  export type SimulationStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * The data used to create many SimulationSteps.
     */
    data: SimulationStepCreateManyInput | SimulationStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimulationStep update
   */
  export type SimulationStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    /**
     * The data needed to update a SimulationStep.
     */
    data: XOR<SimulationStepUpdateInput, SimulationStepUncheckedUpdateInput>
    /**
     * Choose, which SimulationStep to update.
     */
    where: SimulationStepWhereUniqueInput
  }

  /**
   * SimulationStep updateMany
   */
  export type SimulationStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimulationSteps.
     */
    data: XOR<SimulationStepUpdateManyMutationInput, SimulationStepUncheckedUpdateManyInput>
    /**
     * Filter which SimulationSteps to update
     */
    where?: SimulationStepWhereInput
    /**
     * Limit how many SimulationSteps to update.
     */
    limit?: number
  }

  /**
   * SimulationStep updateManyAndReturn
   */
  export type SimulationStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * The data used to update SimulationSteps.
     */
    data: XOR<SimulationStepUpdateManyMutationInput, SimulationStepUncheckedUpdateManyInput>
    /**
     * Filter which SimulationSteps to update
     */
    where?: SimulationStepWhereInput
    /**
     * Limit how many SimulationSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimulationStep upsert
   */
  export type SimulationStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    /**
     * The filter to search for the SimulationStep to update in case it exists.
     */
    where: SimulationStepWhereUniqueInput
    /**
     * In case the SimulationStep found by the `where` argument doesn't exist, create a new SimulationStep with this data.
     */
    create: XOR<SimulationStepCreateInput, SimulationStepUncheckedCreateInput>
    /**
     * In case the SimulationStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationStepUpdateInput, SimulationStepUncheckedUpdateInput>
  }

  /**
   * SimulationStep delete
   */
  export type SimulationStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
    /**
     * Filter which SimulationStep to delete.
     */
    where: SimulationStepWhereUniqueInput
  }

  /**
   * SimulationStep deleteMany
   */
  export type SimulationStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationSteps to delete
     */
    where?: SimulationStepWhereInput
    /**
     * Limit how many SimulationSteps to delete.
     */
    limit?: number
  }

  /**
   * SimulationStep.submissions
   */
  export type SimulationStep$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    cursor?: SubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * SimulationStep without action
   */
  export type SimulationStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationStep
     */
    select?: SimulationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationStep
     */
    omit?: SimulationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationStepInclude<ExtArgs> | null
  }


  /**
   * Model Rubric
   */

  export type AggregateRubric = {
    _count: RubricCountAggregateOutputType | null
    _avg: RubricAvgAggregateOutputType | null
    _sum: RubricSumAggregateOutputType | null
    _min: RubricMinAggregateOutputType | null
    _max: RubricMaxAggregateOutputType | null
  }

  export type RubricAvgAggregateOutputType = {
    passingScore: number | null
  }

  export type RubricSumAggregateOutputType = {
    passingScore: number | null
  }

  export type RubricMinAggregateOutputType = {
    id: string | null
    simulationId: string | null
    passingScore: number | null
    createdAt: Date | null
  }

  export type RubricMaxAggregateOutputType = {
    id: string | null
    simulationId: string | null
    passingScore: number | null
    createdAt: Date | null
  }

  export type RubricCountAggregateOutputType = {
    id: number
    simulationId: number
    criteria: number
    weights: number
    passingScore: number
    createdAt: number
    _all: number
  }


  export type RubricAvgAggregateInputType = {
    passingScore?: true
  }

  export type RubricSumAggregateInputType = {
    passingScore?: true
  }

  export type RubricMinAggregateInputType = {
    id?: true
    simulationId?: true
    passingScore?: true
    createdAt?: true
  }

  export type RubricMaxAggregateInputType = {
    id?: true
    simulationId?: true
    passingScore?: true
    createdAt?: true
  }

  export type RubricCountAggregateInputType = {
    id?: true
    simulationId?: true
    criteria?: true
    weights?: true
    passingScore?: true
    createdAt?: true
    _all?: true
  }

  export type RubricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rubric to aggregate.
     */
    where?: RubricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rubrics to fetch.
     */
    orderBy?: RubricOrderByWithRelationInput | RubricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RubricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rubrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rubrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rubrics
    **/
    _count?: true | RubricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RubricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RubricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RubricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RubricMaxAggregateInputType
  }

  export type GetRubricAggregateType<T extends RubricAggregateArgs> = {
        [P in keyof T & keyof AggregateRubric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRubric[P]>
      : GetScalarType<T[P], AggregateRubric[P]>
  }




  export type RubricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RubricWhereInput
    orderBy?: RubricOrderByWithAggregationInput | RubricOrderByWithAggregationInput[]
    by: RubricScalarFieldEnum[] | RubricScalarFieldEnum
    having?: RubricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RubricCountAggregateInputType | true
    _avg?: RubricAvgAggregateInputType
    _sum?: RubricSumAggregateInputType
    _min?: RubricMinAggregateInputType
    _max?: RubricMaxAggregateInputType
  }

  export type RubricGroupByOutputType = {
    id: string
    simulationId: string
    criteria: JsonValue
    weights: JsonValue
    passingScore: number
    createdAt: Date
    _count: RubricCountAggregateOutputType | null
    _avg: RubricAvgAggregateOutputType | null
    _sum: RubricSumAggregateOutputType | null
    _min: RubricMinAggregateOutputType | null
    _max: RubricMaxAggregateOutputType | null
  }

  type GetRubricGroupByPayload<T extends RubricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RubricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RubricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RubricGroupByOutputType[P]>
            : GetScalarType<T[P], RubricGroupByOutputType[P]>
        }
      >
    >


  export type RubricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    criteria?: boolean
    weights?: boolean
    passingScore?: boolean
    createdAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rubric"]>

  export type RubricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    criteria?: boolean
    weights?: boolean
    passingScore?: boolean
    createdAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rubric"]>

  export type RubricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    criteria?: boolean
    weights?: boolean
    passingScore?: boolean
    createdAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rubric"]>

  export type RubricSelectScalar = {
    id?: boolean
    simulationId?: boolean
    criteria?: boolean
    weights?: boolean
    passingScore?: boolean
    createdAt?: boolean
  }

  export type RubricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "simulationId" | "criteria" | "weights" | "passingScore" | "createdAt", ExtArgs["result"]["rubric"]>
  export type RubricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }
  export type RubricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }
  export type RubricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }

  export type $RubricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rubric"
    objects: {
      simulation: Prisma.$SimulationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      simulationId: string
      criteria: Prisma.JsonValue
      weights: Prisma.JsonValue
      passingScore: number
      createdAt: Date
    }, ExtArgs["result"]["rubric"]>
    composites: {}
  }

  type RubricGetPayload<S extends boolean | null | undefined | RubricDefaultArgs> = $Result.GetResult<Prisma.$RubricPayload, S>

  type RubricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RubricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RubricCountAggregateInputType | true
    }

  export interface RubricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rubric'], meta: { name: 'Rubric' } }
    /**
     * Find zero or one Rubric that matches the filter.
     * @param {RubricFindUniqueArgs} args - Arguments to find a Rubric
     * @example
     * // Get one Rubric
     * const rubric = await prisma.rubric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RubricFindUniqueArgs>(args: SelectSubset<T, RubricFindUniqueArgs<ExtArgs>>): Prisma__RubricClient<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rubric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RubricFindUniqueOrThrowArgs} args - Arguments to find a Rubric
     * @example
     * // Get one Rubric
     * const rubric = await prisma.rubric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RubricFindUniqueOrThrowArgs>(args: SelectSubset<T, RubricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RubricClient<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rubric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricFindFirstArgs} args - Arguments to find a Rubric
     * @example
     * // Get one Rubric
     * const rubric = await prisma.rubric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RubricFindFirstArgs>(args?: SelectSubset<T, RubricFindFirstArgs<ExtArgs>>): Prisma__RubricClient<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rubric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricFindFirstOrThrowArgs} args - Arguments to find a Rubric
     * @example
     * // Get one Rubric
     * const rubric = await prisma.rubric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RubricFindFirstOrThrowArgs>(args?: SelectSubset<T, RubricFindFirstOrThrowArgs<ExtArgs>>): Prisma__RubricClient<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rubrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rubrics
     * const rubrics = await prisma.rubric.findMany()
     * 
     * // Get first 10 Rubrics
     * const rubrics = await prisma.rubric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rubricWithIdOnly = await prisma.rubric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RubricFindManyArgs>(args?: SelectSubset<T, RubricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rubric.
     * @param {RubricCreateArgs} args - Arguments to create a Rubric.
     * @example
     * // Create one Rubric
     * const Rubric = await prisma.rubric.create({
     *   data: {
     *     // ... data to create a Rubric
     *   }
     * })
     * 
     */
    create<T extends RubricCreateArgs>(args: SelectSubset<T, RubricCreateArgs<ExtArgs>>): Prisma__RubricClient<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rubrics.
     * @param {RubricCreateManyArgs} args - Arguments to create many Rubrics.
     * @example
     * // Create many Rubrics
     * const rubric = await prisma.rubric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RubricCreateManyArgs>(args?: SelectSubset<T, RubricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rubrics and returns the data saved in the database.
     * @param {RubricCreateManyAndReturnArgs} args - Arguments to create many Rubrics.
     * @example
     * // Create many Rubrics
     * const rubric = await prisma.rubric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rubrics and only return the `id`
     * const rubricWithIdOnly = await prisma.rubric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RubricCreateManyAndReturnArgs>(args?: SelectSubset<T, RubricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rubric.
     * @param {RubricDeleteArgs} args - Arguments to delete one Rubric.
     * @example
     * // Delete one Rubric
     * const Rubric = await prisma.rubric.delete({
     *   where: {
     *     // ... filter to delete one Rubric
     *   }
     * })
     * 
     */
    delete<T extends RubricDeleteArgs>(args: SelectSubset<T, RubricDeleteArgs<ExtArgs>>): Prisma__RubricClient<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rubric.
     * @param {RubricUpdateArgs} args - Arguments to update one Rubric.
     * @example
     * // Update one Rubric
     * const rubric = await prisma.rubric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RubricUpdateArgs>(args: SelectSubset<T, RubricUpdateArgs<ExtArgs>>): Prisma__RubricClient<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rubrics.
     * @param {RubricDeleteManyArgs} args - Arguments to filter Rubrics to delete.
     * @example
     * // Delete a few Rubrics
     * const { count } = await prisma.rubric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RubricDeleteManyArgs>(args?: SelectSubset<T, RubricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rubrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rubrics
     * const rubric = await prisma.rubric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RubricUpdateManyArgs>(args: SelectSubset<T, RubricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rubrics and returns the data updated in the database.
     * @param {RubricUpdateManyAndReturnArgs} args - Arguments to update many Rubrics.
     * @example
     * // Update many Rubrics
     * const rubric = await prisma.rubric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rubrics and only return the `id`
     * const rubricWithIdOnly = await prisma.rubric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RubricUpdateManyAndReturnArgs>(args: SelectSubset<T, RubricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rubric.
     * @param {RubricUpsertArgs} args - Arguments to update or create a Rubric.
     * @example
     * // Update or create a Rubric
     * const rubric = await prisma.rubric.upsert({
     *   create: {
     *     // ... data to create a Rubric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rubric we want to update
     *   }
     * })
     */
    upsert<T extends RubricUpsertArgs>(args: SelectSubset<T, RubricUpsertArgs<ExtArgs>>): Prisma__RubricClient<$Result.GetResult<Prisma.$RubricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rubrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricCountArgs} args - Arguments to filter Rubrics to count.
     * @example
     * // Count the number of Rubrics
     * const count = await prisma.rubric.count({
     *   where: {
     *     // ... the filter for the Rubrics we want to count
     *   }
     * })
    **/
    count<T extends RubricCountArgs>(
      args?: Subset<T, RubricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RubricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rubric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RubricAggregateArgs>(args: Subset<T, RubricAggregateArgs>): Prisma.PrismaPromise<GetRubricAggregateType<T>>

    /**
     * Group by Rubric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RubricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RubricGroupByArgs['orderBy'] }
        : { orderBy?: RubricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RubricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRubricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rubric model
   */
  readonly fields: RubricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rubric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RubricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    simulation<T extends SimulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationDefaultArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rubric model
   */
  interface RubricFieldRefs {
    readonly id: FieldRef<"Rubric", 'String'>
    readonly simulationId: FieldRef<"Rubric", 'String'>
    readonly criteria: FieldRef<"Rubric", 'Json'>
    readonly weights: FieldRef<"Rubric", 'Json'>
    readonly passingScore: FieldRef<"Rubric", 'Float'>
    readonly createdAt: FieldRef<"Rubric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rubric findUnique
   */
  export type RubricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    /**
     * Filter, which Rubric to fetch.
     */
    where: RubricWhereUniqueInput
  }

  /**
   * Rubric findUniqueOrThrow
   */
  export type RubricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    /**
     * Filter, which Rubric to fetch.
     */
    where: RubricWhereUniqueInput
  }

  /**
   * Rubric findFirst
   */
  export type RubricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    /**
     * Filter, which Rubric to fetch.
     */
    where?: RubricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rubrics to fetch.
     */
    orderBy?: RubricOrderByWithRelationInput | RubricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rubrics.
     */
    cursor?: RubricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rubrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rubrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rubrics.
     */
    distinct?: RubricScalarFieldEnum | RubricScalarFieldEnum[]
  }

  /**
   * Rubric findFirstOrThrow
   */
  export type RubricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    /**
     * Filter, which Rubric to fetch.
     */
    where?: RubricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rubrics to fetch.
     */
    orderBy?: RubricOrderByWithRelationInput | RubricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rubrics.
     */
    cursor?: RubricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rubrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rubrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rubrics.
     */
    distinct?: RubricScalarFieldEnum | RubricScalarFieldEnum[]
  }

  /**
   * Rubric findMany
   */
  export type RubricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    /**
     * Filter, which Rubrics to fetch.
     */
    where?: RubricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rubrics to fetch.
     */
    orderBy?: RubricOrderByWithRelationInput | RubricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rubrics.
     */
    cursor?: RubricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rubrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rubrics.
     */
    skip?: number
    distinct?: RubricScalarFieldEnum | RubricScalarFieldEnum[]
  }

  /**
   * Rubric create
   */
  export type RubricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    /**
     * The data needed to create a Rubric.
     */
    data: XOR<RubricCreateInput, RubricUncheckedCreateInput>
  }

  /**
   * Rubric createMany
   */
  export type RubricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rubrics.
     */
    data: RubricCreateManyInput | RubricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rubric createManyAndReturn
   */
  export type RubricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * The data used to create many Rubrics.
     */
    data: RubricCreateManyInput | RubricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rubric update
   */
  export type RubricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    /**
     * The data needed to update a Rubric.
     */
    data: XOR<RubricUpdateInput, RubricUncheckedUpdateInput>
    /**
     * Choose, which Rubric to update.
     */
    where: RubricWhereUniqueInput
  }

  /**
   * Rubric updateMany
   */
  export type RubricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rubrics.
     */
    data: XOR<RubricUpdateManyMutationInput, RubricUncheckedUpdateManyInput>
    /**
     * Filter which Rubrics to update
     */
    where?: RubricWhereInput
    /**
     * Limit how many Rubrics to update.
     */
    limit?: number
  }

  /**
   * Rubric updateManyAndReturn
   */
  export type RubricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * The data used to update Rubrics.
     */
    data: XOR<RubricUpdateManyMutationInput, RubricUncheckedUpdateManyInput>
    /**
     * Filter which Rubrics to update
     */
    where?: RubricWhereInput
    /**
     * Limit how many Rubrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rubric upsert
   */
  export type RubricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    /**
     * The filter to search for the Rubric to update in case it exists.
     */
    where: RubricWhereUniqueInput
    /**
     * In case the Rubric found by the `where` argument doesn't exist, create a new Rubric with this data.
     */
    create: XOR<RubricCreateInput, RubricUncheckedCreateInput>
    /**
     * In case the Rubric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RubricUpdateInput, RubricUncheckedUpdateInput>
  }

  /**
   * Rubric delete
   */
  export type RubricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
    /**
     * Filter which Rubric to delete.
     */
    where: RubricWhereUniqueInput
  }

  /**
   * Rubric deleteMany
   */
  export type RubricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rubrics to delete
     */
    where?: RubricWhereInput
    /**
     * Limit how many Rubrics to delete.
     */
    limit?: number
  }

  /**
   * Rubric without action
   */
  export type RubricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rubric
     */
    select?: RubricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rubric
     */
    omit?: RubricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubricInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    simulationId: string | null
    candidateId: string | null
    email: string | null
    token: string | null
    status: $Enums.InviteStatus | null
    expiresAt: Date | null
    sentAt: Date | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    simulationId: string | null
    candidateId: string | null
    email: string | null
    token: string | null
    status: $Enums.InviteStatus | null
    expiresAt: Date | null
    sentAt: Date | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    simulationId: number
    candidateId: number
    email: number
    token: number
    status: number
    expiresAt: number
    sentAt: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    simulationId?: true
    candidateId?: true
    email?: true
    token?: true
    status?: true
    expiresAt?: true
    sentAt?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    simulationId?: true
    candidateId?: true
    email?: true
    token?: true
    status?: true
    expiresAt?: true
    sentAt?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    simulationId?: true
    candidateId?: true
    email?: true
    token?: true
    status?: true
    expiresAt?: true
    sentAt?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    simulationId: string
    candidateId: string | null
    email: string
    token: string
    status: $Enums.InviteStatus
    expiresAt: Date
    sentAt: Date
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    candidateId?: boolean
    email?: boolean
    token?: boolean
    status?: boolean
    expiresAt?: boolean
    sentAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    candidate?: boolean | Invitation$candidateArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    candidateId?: boolean
    email?: boolean
    token?: boolean
    status?: boolean
    expiresAt?: boolean
    sentAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    candidate?: boolean | Invitation$candidateArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    candidateId?: boolean
    email?: boolean
    token?: boolean
    status?: boolean
    expiresAt?: boolean
    sentAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    candidate?: boolean | Invitation$candidateArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    simulationId?: boolean
    candidateId?: boolean
    email?: boolean
    token?: boolean
    status?: boolean
    expiresAt?: boolean
    sentAt?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "simulationId" | "candidateId" | "email" | "token" | "status" | "expiresAt" | "sentAt", ExtArgs["result"]["invitation"]>
  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    candidate?: boolean | Invitation$candidateArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    candidate?: boolean | Invitation$candidateArgs<ExtArgs>
  }
  export type InvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    candidate?: boolean | Invitation$candidateArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      simulation: Prisma.$SimulationPayload<ExtArgs>
      candidate: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      simulationId: string
      candidateId: string | null
      email: string
      token: string
      status: $Enums.InviteStatus
      expiresAt: Date
      sentAt: Date
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    simulation<T extends SimulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationDefaultArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    candidate<T extends Invitation$candidateArgs<ExtArgs> = {}>(args?: Subset<T, Invitation$candidateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly simulationId: FieldRef<"Invitation", 'String'>
    readonly candidateId: FieldRef<"Invitation", 'String'>
    readonly email: FieldRef<"Invitation", 'String'>
    readonly token: FieldRef<"Invitation", 'String'>
    readonly status: FieldRef<"Invitation", 'InviteStatus'>
    readonly expiresAt: FieldRef<"Invitation", 'DateTime'>
    readonly sentAt: FieldRef<"Invitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation.candidate
   */
  export type Invitation$candidateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model UserSimulation
   */

  export type AggregateUserSimulation = {
    _count: UserSimulationCountAggregateOutputType | null
    _avg: UserSimulationAvgAggregateOutputType | null
    _sum: UserSimulationSumAggregateOutputType | null
    _min: UserSimulationMinAggregateOutputType | null
    _max: UserSimulationMaxAggregateOutputType | null
  }

  export type UserSimulationAvgAggregateOutputType = {
    timeSpent: number | null
  }

  export type UserSimulationSumAggregateOutputType = {
    timeSpent: number | null
  }

  export type UserSimulationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    simulationId: string | null
    status: $Enums.SimulationStatus | null
    startedAt: Date | null
    completedAt: Date | null
    timeSpent: number | null
  }

  export type UserSimulationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    simulationId: string | null
    status: $Enums.SimulationStatus | null
    startedAt: Date | null
    completedAt: Date | null
    timeSpent: number | null
  }

  export type UserSimulationCountAggregateOutputType = {
    id: number
    userId: number
    simulationId: number
    status: number
    startedAt: number
    completedAt: number
    timeSpent: number
    _all: number
  }


  export type UserSimulationAvgAggregateInputType = {
    timeSpent?: true
  }

  export type UserSimulationSumAggregateInputType = {
    timeSpent?: true
  }

  export type UserSimulationMinAggregateInputType = {
    id?: true
    userId?: true
    simulationId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    timeSpent?: true
  }

  export type UserSimulationMaxAggregateInputType = {
    id?: true
    userId?: true
    simulationId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    timeSpent?: true
  }

  export type UserSimulationCountAggregateInputType = {
    id?: true
    userId?: true
    simulationId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    timeSpent?: true
    _all?: true
  }

  export type UserSimulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSimulation to aggregate.
     */
    where?: UserSimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSimulations to fetch.
     */
    orderBy?: UserSimulationOrderByWithRelationInput | UserSimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSimulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSimulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSimulations
    **/
    _count?: true | UserSimulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSimulationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSimulationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSimulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSimulationMaxAggregateInputType
  }

  export type GetUserSimulationAggregateType<T extends UserSimulationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSimulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSimulation[P]>
      : GetScalarType<T[P], AggregateUserSimulation[P]>
  }




  export type UserSimulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSimulationWhereInput
    orderBy?: UserSimulationOrderByWithAggregationInput | UserSimulationOrderByWithAggregationInput[]
    by: UserSimulationScalarFieldEnum[] | UserSimulationScalarFieldEnum
    having?: UserSimulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSimulationCountAggregateInputType | true
    _avg?: UserSimulationAvgAggregateInputType
    _sum?: UserSimulationSumAggregateInputType
    _min?: UserSimulationMinAggregateInputType
    _max?: UserSimulationMaxAggregateInputType
  }

  export type UserSimulationGroupByOutputType = {
    id: string
    userId: string
    simulationId: string
    status: $Enums.SimulationStatus
    startedAt: Date
    completedAt: Date | null
    timeSpent: number | null
    _count: UserSimulationCountAggregateOutputType | null
    _avg: UserSimulationAvgAggregateOutputType | null
    _sum: UserSimulationSumAggregateOutputType | null
    _min: UserSimulationMinAggregateOutputType | null
    _max: UserSimulationMaxAggregateOutputType | null
  }

  type GetUserSimulationGroupByPayload<T extends UserSimulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSimulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSimulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSimulationGroupByOutputType[P]>
            : GetScalarType<T[P], UserSimulationGroupByOutputType[P]>
        }
      >
    >


  export type UserSimulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    simulationId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSimulation"]>

  export type UserSimulationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    simulationId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSimulation"]>

  export type UserSimulationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    simulationId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSimulation"]>

  export type UserSimulationSelectScalar = {
    id?: boolean
    userId?: boolean
    simulationId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    timeSpent?: boolean
  }

  export type UserSimulationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "simulationId" | "status" | "startedAt" | "completedAt" | "timeSpent", ExtArgs["result"]["userSimulation"]>
  export type UserSimulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }
  export type UserSimulationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }
  export type UserSimulationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }

  export type $UserSimulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSimulation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      simulation: Prisma.$SimulationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      simulationId: string
      status: $Enums.SimulationStatus
      startedAt: Date
      completedAt: Date | null
      timeSpent: number | null
    }, ExtArgs["result"]["userSimulation"]>
    composites: {}
  }

  type UserSimulationGetPayload<S extends boolean | null | undefined | UserSimulationDefaultArgs> = $Result.GetResult<Prisma.$UserSimulationPayload, S>

  type UserSimulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSimulationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSimulationCountAggregateInputType | true
    }

  export interface UserSimulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSimulation'], meta: { name: 'UserSimulation' } }
    /**
     * Find zero or one UserSimulation that matches the filter.
     * @param {UserSimulationFindUniqueArgs} args - Arguments to find a UserSimulation
     * @example
     * // Get one UserSimulation
     * const userSimulation = await prisma.userSimulation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSimulationFindUniqueArgs>(args: SelectSubset<T, UserSimulationFindUniqueArgs<ExtArgs>>): Prisma__UserSimulationClient<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSimulation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSimulationFindUniqueOrThrowArgs} args - Arguments to find a UserSimulation
     * @example
     * // Get one UserSimulation
     * const userSimulation = await prisma.userSimulation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSimulationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSimulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSimulationClient<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSimulation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimulationFindFirstArgs} args - Arguments to find a UserSimulation
     * @example
     * // Get one UserSimulation
     * const userSimulation = await prisma.userSimulation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSimulationFindFirstArgs>(args?: SelectSubset<T, UserSimulationFindFirstArgs<ExtArgs>>): Prisma__UserSimulationClient<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSimulation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimulationFindFirstOrThrowArgs} args - Arguments to find a UserSimulation
     * @example
     * // Get one UserSimulation
     * const userSimulation = await prisma.userSimulation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSimulationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSimulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSimulationClient<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSimulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSimulations
     * const userSimulations = await prisma.userSimulation.findMany()
     * 
     * // Get first 10 UserSimulations
     * const userSimulations = await prisma.userSimulation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSimulationWithIdOnly = await prisma.userSimulation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSimulationFindManyArgs>(args?: SelectSubset<T, UserSimulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSimulation.
     * @param {UserSimulationCreateArgs} args - Arguments to create a UserSimulation.
     * @example
     * // Create one UserSimulation
     * const UserSimulation = await prisma.userSimulation.create({
     *   data: {
     *     // ... data to create a UserSimulation
     *   }
     * })
     * 
     */
    create<T extends UserSimulationCreateArgs>(args: SelectSubset<T, UserSimulationCreateArgs<ExtArgs>>): Prisma__UserSimulationClient<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSimulations.
     * @param {UserSimulationCreateManyArgs} args - Arguments to create many UserSimulations.
     * @example
     * // Create many UserSimulations
     * const userSimulation = await prisma.userSimulation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSimulationCreateManyArgs>(args?: SelectSubset<T, UserSimulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSimulations and returns the data saved in the database.
     * @param {UserSimulationCreateManyAndReturnArgs} args - Arguments to create many UserSimulations.
     * @example
     * // Create many UserSimulations
     * const userSimulation = await prisma.userSimulation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSimulations and only return the `id`
     * const userSimulationWithIdOnly = await prisma.userSimulation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSimulationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSimulationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSimulation.
     * @param {UserSimulationDeleteArgs} args - Arguments to delete one UserSimulation.
     * @example
     * // Delete one UserSimulation
     * const UserSimulation = await prisma.userSimulation.delete({
     *   where: {
     *     // ... filter to delete one UserSimulation
     *   }
     * })
     * 
     */
    delete<T extends UserSimulationDeleteArgs>(args: SelectSubset<T, UserSimulationDeleteArgs<ExtArgs>>): Prisma__UserSimulationClient<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSimulation.
     * @param {UserSimulationUpdateArgs} args - Arguments to update one UserSimulation.
     * @example
     * // Update one UserSimulation
     * const userSimulation = await prisma.userSimulation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSimulationUpdateArgs>(args: SelectSubset<T, UserSimulationUpdateArgs<ExtArgs>>): Prisma__UserSimulationClient<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSimulations.
     * @param {UserSimulationDeleteManyArgs} args - Arguments to filter UserSimulations to delete.
     * @example
     * // Delete a few UserSimulations
     * const { count } = await prisma.userSimulation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSimulationDeleteManyArgs>(args?: SelectSubset<T, UserSimulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSimulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSimulations
     * const userSimulation = await prisma.userSimulation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSimulationUpdateManyArgs>(args: SelectSubset<T, UserSimulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSimulations and returns the data updated in the database.
     * @param {UserSimulationUpdateManyAndReturnArgs} args - Arguments to update many UserSimulations.
     * @example
     * // Update many UserSimulations
     * const userSimulation = await prisma.userSimulation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSimulations and only return the `id`
     * const userSimulationWithIdOnly = await prisma.userSimulation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSimulationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSimulationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSimulation.
     * @param {UserSimulationUpsertArgs} args - Arguments to update or create a UserSimulation.
     * @example
     * // Update or create a UserSimulation
     * const userSimulation = await prisma.userSimulation.upsert({
     *   create: {
     *     // ... data to create a UserSimulation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSimulation we want to update
     *   }
     * })
     */
    upsert<T extends UserSimulationUpsertArgs>(args: SelectSubset<T, UserSimulationUpsertArgs<ExtArgs>>): Prisma__UserSimulationClient<$Result.GetResult<Prisma.$UserSimulationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSimulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimulationCountArgs} args - Arguments to filter UserSimulations to count.
     * @example
     * // Count the number of UserSimulations
     * const count = await prisma.userSimulation.count({
     *   where: {
     *     // ... the filter for the UserSimulations we want to count
     *   }
     * })
    **/
    count<T extends UserSimulationCountArgs>(
      args?: Subset<T, UserSimulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSimulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSimulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSimulationAggregateArgs>(args: Subset<T, UserSimulationAggregateArgs>): Prisma.PrismaPromise<GetUserSimulationAggregateType<T>>

    /**
     * Group by UserSimulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSimulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSimulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSimulationGroupByArgs['orderBy'] }
        : { orderBy?: UserSimulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSimulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSimulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSimulation model
   */
  readonly fields: UserSimulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSimulation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSimulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    simulation<T extends SimulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationDefaultArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSimulation model
   */
  interface UserSimulationFieldRefs {
    readonly id: FieldRef<"UserSimulation", 'String'>
    readonly userId: FieldRef<"UserSimulation", 'String'>
    readonly simulationId: FieldRef<"UserSimulation", 'String'>
    readonly status: FieldRef<"UserSimulation", 'SimulationStatus'>
    readonly startedAt: FieldRef<"UserSimulation", 'DateTime'>
    readonly completedAt: FieldRef<"UserSimulation", 'DateTime'>
    readonly timeSpent: FieldRef<"UserSimulation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserSimulation findUnique
   */
  export type UserSimulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    /**
     * Filter, which UserSimulation to fetch.
     */
    where: UserSimulationWhereUniqueInput
  }

  /**
   * UserSimulation findUniqueOrThrow
   */
  export type UserSimulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    /**
     * Filter, which UserSimulation to fetch.
     */
    where: UserSimulationWhereUniqueInput
  }

  /**
   * UserSimulation findFirst
   */
  export type UserSimulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    /**
     * Filter, which UserSimulation to fetch.
     */
    where?: UserSimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSimulations to fetch.
     */
    orderBy?: UserSimulationOrderByWithRelationInput | UserSimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSimulations.
     */
    cursor?: UserSimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSimulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSimulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSimulations.
     */
    distinct?: UserSimulationScalarFieldEnum | UserSimulationScalarFieldEnum[]
  }

  /**
   * UserSimulation findFirstOrThrow
   */
  export type UserSimulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    /**
     * Filter, which UserSimulation to fetch.
     */
    where?: UserSimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSimulations to fetch.
     */
    orderBy?: UserSimulationOrderByWithRelationInput | UserSimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSimulations.
     */
    cursor?: UserSimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSimulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSimulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSimulations.
     */
    distinct?: UserSimulationScalarFieldEnum | UserSimulationScalarFieldEnum[]
  }

  /**
   * UserSimulation findMany
   */
  export type UserSimulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    /**
     * Filter, which UserSimulations to fetch.
     */
    where?: UserSimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSimulations to fetch.
     */
    orderBy?: UserSimulationOrderByWithRelationInput | UserSimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSimulations.
     */
    cursor?: UserSimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSimulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSimulations.
     */
    skip?: number
    distinct?: UserSimulationScalarFieldEnum | UserSimulationScalarFieldEnum[]
  }

  /**
   * UserSimulation create
   */
  export type UserSimulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSimulation.
     */
    data: XOR<UserSimulationCreateInput, UserSimulationUncheckedCreateInput>
  }

  /**
   * UserSimulation createMany
   */
  export type UserSimulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSimulations.
     */
    data: UserSimulationCreateManyInput | UserSimulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSimulation createManyAndReturn
   */
  export type UserSimulationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * The data used to create many UserSimulations.
     */
    data: UserSimulationCreateManyInput | UserSimulationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSimulation update
   */
  export type UserSimulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSimulation.
     */
    data: XOR<UserSimulationUpdateInput, UserSimulationUncheckedUpdateInput>
    /**
     * Choose, which UserSimulation to update.
     */
    where: UserSimulationWhereUniqueInput
  }

  /**
   * UserSimulation updateMany
   */
  export type UserSimulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSimulations.
     */
    data: XOR<UserSimulationUpdateManyMutationInput, UserSimulationUncheckedUpdateManyInput>
    /**
     * Filter which UserSimulations to update
     */
    where?: UserSimulationWhereInput
    /**
     * Limit how many UserSimulations to update.
     */
    limit?: number
  }

  /**
   * UserSimulation updateManyAndReturn
   */
  export type UserSimulationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * The data used to update UserSimulations.
     */
    data: XOR<UserSimulationUpdateManyMutationInput, UserSimulationUncheckedUpdateManyInput>
    /**
     * Filter which UserSimulations to update
     */
    where?: UserSimulationWhereInput
    /**
     * Limit how many UserSimulations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSimulation upsert
   */
  export type UserSimulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSimulation to update in case it exists.
     */
    where: UserSimulationWhereUniqueInput
    /**
     * In case the UserSimulation found by the `where` argument doesn't exist, create a new UserSimulation with this data.
     */
    create: XOR<UserSimulationCreateInput, UserSimulationUncheckedCreateInput>
    /**
     * In case the UserSimulation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSimulationUpdateInput, UserSimulationUncheckedUpdateInput>
  }

  /**
   * UserSimulation delete
   */
  export type UserSimulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
    /**
     * Filter which UserSimulation to delete.
     */
    where: UserSimulationWhereUniqueInput
  }

  /**
   * UserSimulation deleteMany
   */
  export type UserSimulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSimulations to delete
     */
    where?: UserSimulationWhereInput
    /**
     * Limit how many UserSimulations to delete.
     */
    limit?: number
  }

  /**
   * UserSimulation without action
   */
  export type UserSimulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSimulation
     */
    select?: UserSimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSimulation
     */
    omit?: UserSimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSimulationInclude<ExtArgs> | null
  }


  /**
   * Model Submission
   */

  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  export type SubmissionAvgAggregateOutputType = {
    score: number | null
  }

  export type SubmissionSumAggregateOutputType = {
    score: number | null
  }

  export type SubmissionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    simulationId: string | null
    stepId: string | null
    score: number | null
    completedAt: Date | null
  }

  export type SubmissionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    simulationId: string | null
    stepId: string | null
    score: number | null
    completedAt: Date | null
  }

  export type SubmissionCountAggregateOutputType = {
    id: number
    userId: number
    simulationId: number
    stepId: number
    content: number
    aiFeedback: number
    score: number
    completedAt: number
    integrityFlags: number
    _all: number
  }


  export type SubmissionAvgAggregateInputType = {
    score?: true
  }

  export type SubmissionSumAggregateInputType = {
    score?: true
  }

  export type SubmissionMinAggregateInputType = {
    id?: true
    userId?: true
    simulationId?: true
    stepId?: true
    score?: true
    completedAt?: true
  }

  export type SubmissionMaxAggregateInputType = {
    id?: true
    userId?: true
    simulationId?: true
    stepId?: true
    score?: true
    completedAt?: true
  }

  export type SubmissionCountAggregateInputType = {
    id?: true
    userId?: true
    simulationId?: true
    stepId?: true
    content?: true
    aiFeedback?: true
    score?: true
    completedAt?: true
    integrityFlags?: true
    _all?: true
  }

  export type SubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submission to aggregate.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Submissions
    **/
    _count?: true | SubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionMaxAggregateInputType
  }

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>
  }




  export type SubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithAggregationInput | SubmissionOrderByWithAggregationInput[]
    by: SubmissionScalarFieldEnum[] | SubmissionScalarFieldEnum
    having?: SubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionCountAggregateInputType | true
    _avg?: SubmissionAvgAggregateInputType
    _sum?: SubmissionSumAggregateInputType
    _min?: SubmissionMinAggregateInputType
    _max?: SubmissionMaxAggregateInputType
  }

  export type SubmissionGroupByOutputType = {
    id: string
    userId: string
    simulationId: string
    stepId: string
    content: JsonValue
    aiFeedback: JsonValue | null
    score: number | null
    completedAt: Date
    integrityFlags: string[]
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  type GetSubmissionGroupByPayload<T extends SubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    simulationId?: boolean
    stepId?: boolean
    content?: boolean
    aiFeedback?: boolean
    score?: boolean
    completedAt?: boolean
    integrityFlags?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    step?: boolean | SimulationStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type SubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    simulationId?: boolean
    stepId?: boolean
    content?: boolean
    aiFeedback?: boolean
    score?: boolean
    completedAt?: boolean
    integrityFlags?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    step?: boolean | SimulationStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type SubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    simulationId?: boolean
    stepId?: boolean
    content?: boolean
    aiFeedback?: boolean
    score?: boolean
    completedAt?: boolean
    integrityFlags?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    step?: boolean | SimulationStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type SubmissionSelectScalar = {
    id?: boolean
    userId?: boolean
    simulationId?: boolean
    stepId?: boolean
    content?: boolean
    aiFeedback?: boolean
    score?: boolean
    completedAt?: boolean
    integrityFlags?: boolean
  }

  export type SubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "simulationId" | "stepId" | "content" | "aiFeedback" | "score" | "completedAt" | "integrityFlags", ExtArgs["result"]["submission"]>
  export type SubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    step?: boolean | SimulationStepDefaultArgs<ExtArgs>
  }
  export type SubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    step?: boolean | SimulationStepDefaultArgs<ExtArgs>
  }
  export type SubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    step?: boolean | SimulationStepDefaultArgs<ExtArgs>
  }

  export type $SubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Submission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      simulation: Prisma.$SimulationPayload<ExtArgs>
      step: Prisma.$SimulationStepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      simulationId: string
      stepId: string
      content: Prisma.JsonValue
      aiFeedback: Prisma.JsonValue | null
      score: number | null
      completedAt: Date
      integrityFlags: string[]
    }, ExtArgs["result"]["submission"]>
    composites: {}
  }

  type SubmissionGetPayload<S extends boolean | null | undefined | SubmissionDefaultArgs> = $Result.GetResult<Prisma.$SubmissionPayload, S>

  type SubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubmissionCountAggregateInputType | true
    }

  export interface SubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Submission'], meta: { name: 'Submission' } }
    /**
     * Find zero or one Submission that matches the filter.
     * @param {SubmissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionFindUniqueArgs>(args: SelectSubset<T, SubmissionFindUniqueArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Submission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubmissionFindUniqueOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionFindFirstArgs>(args?: SelectSubset<T, SubmissionFindFirstArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     * 
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionWithIdOnly = await prisma.submission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubmissionFindManyArgs>(args?: SelectSubset<T, SubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Submission.
     * @param {SubmissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     * 
     */
    create<T extends SubmissionCreateArgs>(args: SelectSubset<T, SubmissionCreateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Submissions.
     * @param {SubmissionCreateManyArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubmissionCreateManyArgs>(args?: SelectSubset<T, SubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Submissions and returns the data saved in the database.
     * @param {SubmissionCreateManyAndReturnArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Submissions and only return the `id`
     * const submissionWithIdOnly = await prisma.submission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Submission.
     * @param {SubmissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     * 
     */
    delete<T extends SubmissionDeleteArgs>(args: SelectSubset<T, SubmissionDeleteArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Submission.
     * @param {SubmissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubmissionUpdateArgs>(args: SelectSubset<T, SubmissionUpdateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Submissions.
     * @param {SubmissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubmissionDeleteManyArgs>(args?: SelectSubset<T, SubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubmissionUpdateManyArgs>(args: SelectSubset<T, SubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions and returns the data updated in the database.
     * @param {SubmissionUpdateManyAndReturnArgs} args - Arguments to update many Submissions.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Submissions and only return the `id`
     * const submissionWithIdOnly = await prisma.submission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Submission.
     * @param {SubmissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionUpsertArgs>(args: SelectSubset<T, SubmissionUpsertArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
    **/
    count<T extends SubmissionCountArgs>(
      args?: Subset<T, SubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionAggregateArgs>(args: Subset<T, SubmissionAggregateArgs>): Prisma.PrismaPromise<GetSubmissionAggregateType<T>>

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Submission model
   */
  readonly fields: SubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    simulation<T extends SimulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationDefaultArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    step<T extends SimulationStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationStepDefaultArgs<ExtArgs>>): Prisma__SimulationStepClient<$Result.GetResult<Prisma.$SimulationStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Submission model
   */
  interface SubmissionFieldRefs {
    readonly id: FieldRef<"Submission", 'String'>
    readonly userId: FieldRef<"Submission", 'String'>
    readonly simulationId: FieldRef<"Submission", 'String'>
    readonly stepId: FieldRef<"Submission", 'String'>
    readonly content: FieldRef<"Submission", 'Json'>
    readonly aiFeedback: FieldRef<"Submission", 'Json'>
    readonly score: FieldRef<"Submission", 'Float'>
    readonly completedAt: FieldRef<"Submission", 'DateTime'>
    readonly integrityFlags: FieldRef<"Submission", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Submission findUnique
   */
  export type SubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findUniqueOrThrow
   */
  export type SubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findFirst
   */
  export type SubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findFirstOrThrow
   */
  export type SubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findMany
   */
  export type SubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submissions to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission create
   */
  export type SubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Submission.
     */
    data: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
  }

  /**
   * Submission createMany
   */
  export type SubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Submission createManyAndReturn
   */
  export type SubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Submission update
   */
  export type SubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Submission.
     */
    data: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
    /**
     * Choose, which Submission to update.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission updateMany
   */
  export type SubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Submissions.
     */
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyInput>
    /**
     * Filter which Submissions to update
     */
    where?: SubmissionWhereInput
    /**
     * Limit how many Submissions to update.
     */
    limit?: number
  }

  /**
   * Submission updateManyAndReturn
   */
  export type SubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * The data used to update Submissions.
     */
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyInput>
    /**
     * Filter which Submissions to update
     */
    where?: SubmissionWhereInput
    /**
     * Limit how many Submissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Submission upsert
   */
  export type SubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Submission to update in case it exists.
     */
    where: SubmissionWhereUniqueInput
    /**
     * In case the Submission found by the `where` argument doesn't exist, create a new Submission with this data.
     */
    create: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
    /**
     * In case the Submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
  }

  /**
   * Submission delete
   */
  export type SubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter which Submission to delete.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission deleteMany
   */
  export type SubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submissions to delete
     */
    where?: SubmissionWhereInput
    /**
     * Limit how many Submissions to delete.
     */
    limit?: number
  }

  /**
   * Submission without action
   */
  export type SubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Analytics
   */

  export type AggregateAnalytics = {
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  export type AnalyticsAvgAggregateOutputType = {
    totalCandidates: number | null
    avgScore: number | null
    completionRate: number | null
  }

  export type AnalyticsSumAggregateOutputType = {
    totalCandidates: number | null
    avgScore: number | null
    completionRate: number | null
  }

  export type AnalyticsMinAggregateOutputType = {
    id: string | null
    simulationId: string | null
    totalCandidates: number | null
    avgScore: number | null
    completionRate: number | null
    createdAt: Date | null
  }

  export type AnalyticsMaxAggregateOutputType = {
    id: string | null
    simulationId: string | null
    totalCandidates: number | null
    avgScore: number | null
    completionRate: number | null
    createdAt: Date | null
  }

  export type AnalyticsCountAggregateOutputType = {
    id: number
    simulationId: number
    totalCandidates: number
    avgScore: number
    completionRate: number
    diversityData: number
    createdAt: number
    _all: number
  }


  export type AnalyticsAvgAggregateInputType = {
    totalCandidates?: true
    avgScore?: true
    completionRate?: true
  }

  export type AnalyticsSumAggregateInputType = {
    totalCandidates?: true
    avgScore?: true
    completionRate?: true
  }

  export type AnalyticsMinAggregateInputType = {
    id?: true
    simulationId?: true
    totalCandidates?: true
    avgScore?: true
    completionRate?: true
    createdAt?: true
  }

  export type AnalyticsMaxAggregateInputType = {
    id?: true
    simulationId?: true
    totalCandidates?: true
    avgScore?: true
    completionRate?: true
    createdAt?: true
  }

  export type AnalyticsCountAggregateInputType = {
    id?: true
    simulationId?: true
    totalCandidates?: true
    avgScore?: true
    completionRate?: true
    diversityData?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to aggregate.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Analytics
    **/
    _count?: true | AnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsMaxAggregateInputType
  }

  export type GetAnalyticsAggregateType<T extends AnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalytics[P]>
      : GetScalarType<T[P], AggregateAnalytics[P]>
  }




  export type AnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithAggregationInput | AnalyticsOrderByWithAggregationInput[]
    by: AnalyticsScalarFieldEnum[] | AnalyticsScalarFieldEnum
    having?: AnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsCountAggregateInputType | true
    _avg?: AnalyticsAvgAggregateInputType
    _sum?: AnalyticsSumAggregateInputType
    _min?: AnalyticsMinAggregateInputType
    _max?: AnalyticsMaxAggregateInputType
  }

  export type AnalyticsGroupByOutputType = {
    id: string
    simulationId: string
    totalCandidates: number
    avgScore: number
    completionRate: number
    diversityData: JsonValue | null
    createdAt: Date
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  type GetAnalyticsGroupByPayload<T extends AnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    totalCandidates?: boolean
    avgScore?: boolean
    completionRate?: boolean
    diversityData?: boolean
    createdAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    totalCandidates?: boolean
    avgScore?: boolean
    completionRate?: boolean
    diversityData?: boolean
    createdAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    totalCandidates?: boolean
    avgScore?: boolean
    completionRate?: boolean
    diversityData?: boolean
    createdAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectScalar = {
    id?: boolean
    simulationId?: boolean
    totalCandidates?: boolean
    avgScore?: boolean
    completionRate?: boolean
    diversityData?: boolean
    createdAt?: boolean
  }

  export type AnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "simulationId" | "totalCandidates" | "avgScore" | "completionRate" | "diversityData" | "createdAt", ExtArgs["result"]["analytics"]>
  export type AnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }
  export type AnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }
  export type AnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }

  export type $AnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Analytics"
    objects: {
      simulation: Prisma.$SimulationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      simulationId: string
      totalCandidates: number
      avgScore: number
      completionRate: number
      diversityData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["analytics"]>
    composites: {}
  }

  type AnalyticsGetPayload<S extends boolean | null | undefined | AnalyticsDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsPayload, S>

  type AnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsCountAggregateInputType | true
    }

  export interface AnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Analytics'], meta: { name: 'Analytics' } }
    /**
     * Find zero or one Analytics that matches the filter.
     * @param {AnalyticsFindUniqueArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsFindUniqueArgs>(args: SelectSubset<T, AnalyticsFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Analytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsFindUniqueOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsFindFirstArgs>(args?: SelectSubset<T, AnalyticsFindFirstArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analytics
     * const analytics = await prisma.analytics.findMany()
     * 
     * // Get first 10 Analytics
     * const analytics = await prisma.analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsWithIdOnly = await prisma.analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsFindManyArgs>(args?: SelectSubset<T, AnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Analytics.
     * @param {AnalyticsCreateArgs} args - Arguments to create a Analytics.
     * @example
     * // Create one Analytics
     * const Analytics = await prisma.analytics.create({
     *   data: {
     *     // ... data to create a Analytics
     *   }
     * })
     * 
     */
    create<T extends AnalyticsCreateArgs>(args: SelectSubset<T, AnalyticsCreateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Analytics.
     * @param {AnalyticsCreateManyArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsCreateManyArgs>(args?: SelectSubset<T, AnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analytics and returns the data saved in the database.
     * @param {AnalyticsCreateManyAndReturnArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Analytics.
     * @param {AnalyticsDeleteArgs} args - Arguments to delete one Analytics.
     * @example
     * // Delete one Analytics
     * const Analytics = await prisma.analytics.delete({
     *   where: {
     *     // ... filter to delete one Analytics
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsDeleteArgs>(args: SelectSubset<T, AnalyticsDeleteArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Analytics.
     * @param {AnalyticsUpdateArgs} args - Arguments to update one Analytics.
     * @example
     * // Update one Analytics
     * const analytics = await prisma.analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsUpdateArgs>(args: SelectSubset<T, AnalyticsUpdateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Analytics.
     * @param {AnalyticsDeleteManyArgs} args - Arguments to filter Analytics to delete.
     * @example
     * // Delete a few Analytics
     * const { count } = await prisma.analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsDeleteManyArgs>(args?: SelectSubset<T, AnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsUpdateManyArgs>(args: SelectSubset<T, AnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics and returns the data updated in the database.
     * @param {AnalyticsUpdateManyAndReturnArgs} args - Arguments to update many Analytics.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Analytics.
     * @param {AnalyticsUpsertArgs} args - Arguments to update or create a Analytics.
     * @example
     * // Update or create a Analytics
     * const analytics = await prisma.analytics.upsert({
     *   create: {
     *     // ... data to create a Analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analytics we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsUpsertArgs>(args: SelectSubset<T, AnalyticsUpsertArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCountArgs} args - Arguments to filter Analytics to count.
     * @example
     * // Count the number of Analytics
     * const count = await prisma.analytics.count({
     *   where: {
     *     // ... the filter for the Analytics we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsCountArgs>(
      args?: Subset<T, AnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAggregateArgs>(args: Subset<T, AnalyticsAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAggregateType<T>>

    /**
     * Group by Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Analytics model
   */
  readonly fields: AnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    simulation<T extends SimulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationDefaultArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Analytics model
   */
  interface AnalyticsFieldRefs {
    readonly id: FieldRef<"Analytics", 'String'>
    readonly simulationId: FieldRef<"Analytics", 'String'>
    readonly totalCandidates: FieldRef<"Analytics", 'Int'>
    readonly avgScore: FieldRef<"Analytics", 'Float'>
    readonly completionRate: FieldRef<"Analytics", 'Float'>
    readonly diversityData: FieldRef<"Analytics", 'Json'>
    readonly createdAt: FieldRef<"Analytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Analytics findUnique
   */
  export type AnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findUniqueOrThrow
   */
  export type AnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findFirst
   */
  export type AnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findFirstOrThrow
   */
  export type AnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findMany
   */
  export type AnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics create
   */
  export type AnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a Analytics.
     */
    data: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
  }

  /**
   * Analytics createMany
   */
  export type AnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics createManyAndReturn
   */
  export type AnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Analytics update
   */
  export type AnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a Analytics.
     */
    data: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
    /**
     * Choose, which Analytics to update.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics updateMany
   */
  export type AnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
  }

  /**
   * Analytics updateManyAndReturn
   */
  export type AnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Analytics upsert
   */
  export type AnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the Analytics to update in case it exists.
     */
    where: AnalyticsWhereUniqueInput
    /**
     * In case the Analytics found by the `where` argument doesn't exist, create a new Analytics with this data.
     */
    create: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
    /**
     * In case the Analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
  }

  /**
   * Analytics delete
   */
  export type AnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter which Analytics to delete.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics deleteMany
   */
  export type AnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to delete
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to delete.
     */
    limit?: number
  }

  /**
   * Analytics without action
   */
  export type AnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    firstName: 'firstName',
    lastName: 'lastName',
    company: 'company',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SimulationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    duration: 'duration',
    isPublished: 'isPublished',
    isBlindMode: 'isBlindMode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    employerId: 'employerId'
  };

  export type SimulationScalarFieldEnum = (typeof SimulationScalarFieldEnum)[keyof typeof SimulationScalarFieldEnum]


  export const SimulationStepScalarFieldEnum: {
    id: 'id',
    simulationId: 'simulationId',
    type: 'type',
    title: 'title',
    instructions: 'instructions',
    content: 'content',
    order: 'order',
    aiPersona: 'aiPersona',
    expectedOutput: 'expectedOutput'
  };

  export type SimulationStepScalarFieldEnum = (typeof SimulationStepScalarFieldEnum)[keyof typeof SimulationStepScalarFieldEnum]


  export const RubricScalarFieldEnum: {
    id: 'id',
    simulationId: 'simulationId',
    criteria: 'criteria',
    weights: 'weights',
    passingScore: 'passingScore',
    createdAt: 'createdAt'
  };

  export type RubricScalarFieldEnum = (typeof RubricScalarFieldEnum)[keyof typeof RubricScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    simulationId: 'simulationId',
    candidateId: 'candidateId',
    email: 'email',
    token: 'token',
    status: 'status',
    expiresAt: 'expiresAt',
    sentAt: 'sentAt'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const UserSimulationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    simulationId: 'simulationId',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    timeSpent: 'timeSpent'
  };

  export type UserSimulationScalarFieldEnum = (typeof UserSimulationScalarFieldEnum)[keyof typeof UserSimulationScalarFieldEnum]


  export const SubmissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    simulationId: 'simulationId',
    stepId: 'stepId',
    content: 'content',
    aiFeedback: 'aiFeedback',
    score: 'score',
    completedAt: 'completedAt',
    integrityFlags: 'integrityFlags'
  };

  export type SubmissionScalarFieldEnum = (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum]


  export const AnalyticsScalarFieldEnum: {
    id: 'id',
    simulationId: 'simulationId',
    totalCandidates: 'totalCandidates',
    avgScore: 'avgScore',
    completionRate: 'completionRate',
    diversityData: 'diversityData',
    createdAt: 'createdAt'
  };

  export type AnalyticsScalarFieldEnum = (typeof AnalyticsScalarFieldEnum)[keyof typeof AnalyticsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'StepType'
   */
  export type EnumStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepType'>
    


  /**
   * Reference to a field of type 'StepType[]'
   */
  export type ListEnumStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'InviteStatus'
   */
  export type EnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus'>
    


  /**
   * Reference to a field of type 'InviteStatus[]'
   */
  export type ListEnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus[]'>
    


  /**
   * Reference to a field of type 'SimulationStatus'
   */
  export type EnumSimulationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimulationStatus'>
    


  /**
   * Reference to a field of type 'SimulationStatus[]'
   */
  export type ListEnumSimulationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimulationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    company?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdSimulations?: SimulationListRelationFilter
    simulations?: UserSimulationListRelationFilter
    submissions?: SubmissionListRelationFilter
    invitations?: InvitationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdSimulations?: SimulationOrderByRelationAggregateInput
    simulations?: UserSimulationOrderByRelationAggregateInput
    submissions?: SubmissionOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    company?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdSimulations?: SimulationListRelationFilter
    simulations?: UserSimulationListRelationFilter
    submissions?: SubmissionListRelationFilter
    invitations?: InvitationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    company?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SimulationWhereInput = {
    AND?: SimulationWhereInput | SimulationWhereInput[]
    OR?: SimulationWhereInput[]
    NOT?: SimulationWhereInput | SimulationWhereInput[]
    id?: StringFilter<"Simulation"> | string
    title?: StringFilter<"Simulation"> | string
    description?: StringNullableFilter<"Simulation"> | string | null
    duration?: IntFilter<"Simulation"> | number
    isPublished?: BoolFilter<"Simulation"> | boolean
    isBlindMode?: BoolFilter<"Simulation"> | boolean
    createdAt?: DateTimeFilter<"Simulation"> | Date | string
    updatedAt?: DateTimeFilter<"Simulation"> | Date | string
    employerId?: StringFilter<"Simulation"> | string
    employer?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: SimulationStepListRelationFilter
    invitations?: InvitationListRelationFilter
    submissions?: SubmissionListRelationFilter
    rubric?: XOR<RubricNullableScalarRelationFilter, RubricWhereInput> | null
    userSimulations?: UserSimulationListRelationFilter
    analytics?: AnalyticsListRelationFilter
  }

  export type SimulationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    isPublished?: SortOrder
    isBlindMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employerId?: SortOrder
    employer?: UserOrderByWithRelationInput
    steps?: SimulationStepOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
    submissions?: SubmissionOrderByRelationAggregateInput
    rubric?: RubricOrderByWithRelationInput
    userSimulations?: UserSimulationOrderByRelationAggregateInput
    analytics?: AnalyticsOrderByRelationAggregateInput
  }

  export type SimulationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SimulationWhereInput | SimulationWhereInput[]
    OR?: SimulationWhereInput[]
    NOT?: SimulationWhereInput | SimulationWhereInput[]
    title?: StringFilter<"Simulation"> | string
    description?: StringNullableFilter<"Simulation"> | string | null
    duration?: IntFilter<"Simulation"> | number
    isPublished?: BoolFilter<"Simulation"> | boolean
    isBlindMode?: BoolFilter<"Simulation"> | boolean
    createdAt?: DateTimeFilter<"Simulation"> | Date | string
    updatedAt?: DateTimeFilter<"Simulation"> | Date | string
    employerId?: StringFilter<"Simulation"> | string
    employer?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: SimulationStepListRelationFilter
    invitations?: InvitationListRelationFilter
    submissions?: SubmissionListRelationFilter
    rubric?: XOR<RubricNullableScalarRelationFilter, RubricWhereInput> | null
    userSimulations?: UserSimulationListRelationFilter
    analytics?: AnalyticsListRelationFilter
  }, "id">

  export type SimulationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    isPublished?: SortOrder
    isBlindMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employerId?: SortOrder
    _count?: SimulationCountOrderByAggregateInput
    _avg?: SimulationAvgOrderByAggregateInput
    _max?: SimulationMaxOrderByAggregateInput
    _min?: SimulationMinOrderByAggregateInput
    _sum?: SimulationSumOrderByAggregateInput
  }

  export type SimulationScalarWhereWithAggregatesInput = {
    AND?: SimulationScalarWhereWithAggregatesInput | SimulationScalarWhereWithAggregatesInput[]
    OR?: SimulationScalarWhereWithAggregatesInput[]
    NOT?: SimulationScalarWhereWithAggregatesInput | SimulationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Simulation"> | string
    title?: StringWithAggregatesFilter<"Simulation"> | string
    description?: StringNullableWithAggregatesFilter<"Simulation"> | string | null
    duration?: IntWithAggregatesFilter<"Simulation"> | number
    isPublished?: BoolWithAggregatesFilter<"Simulation"> | boolean
    isBlindMode?: BoolWithAggregatesFilter<"Simulation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Simulation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Simulation"> | Date | string
    employerId?: StringWithAggregatesFilter<"Simulation"> | string
  }

  export type SimulationStepWhereInput = {
    AND?: SimulationStepWhereInput | SimulationStepWhereInput[]
    OR?: SimulationStepWhereInput[]
    NOT?: SimulationStepWhereInput | SimulationStepWhereInput[]
    id?: StringFilter<"SimulationStep"> | string
    simulationId?: StringFilter<"SimulationStep"> | string
    type?: EnumStepTypeFilter<"SimulationStep"> | $Enums.StepType
    title?: StringFilter<"SimulationStep"> | string
    instructions?: StringFilter<"SimulationStep"> | string
    content?: JsonNullableFilter<"SimulationStep">
    order?: IntFilter<"SimulationStep"> | number
    aiPersona?: StringNullableFilter<"SimulationStep"> | string | null
    expectedOutput?: JsonNullableFilter<"SimulationStep">
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    submissions?: SubmissionListRelationFilter
  }

  export type SimulationStepOrderByWithRelationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
    content?: SortOrderInput | SortOrder
    order?: SortOrder
    aiPersona?: SortOrderInput | SortOrder
    expectedOutput?: SortOrderInput | SortOrder
    simulation?: SimulationOrderByWithRelationInput
    submissions?: SubmissionOrderByRelationAggregateInput
  }

  export type SimulationStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SimulationStepWhereInput | SimulationStepWhereInput[]
    OR?: SimulationStepWhereInput[]
    NOT?: SimulationStepWhereInput | SimulationStepWhereInput[]
    simulationId?: StringFilter<"SimulationStep"> | string
    type?: EnumStepTypeFilter<"SimulationStep"> | $Enums.StepType
    title?: StringFilter<"SimulationStep"> | string
    instructions?: StringFilter<"SimulationStep"> | string
    content?: JsonNullableFilter<"SimulationStep">
    order?: IntFilter<"SimulationStep"> | number
    aiPersona?: StringNullableFilter<"SimulationStep"> | string | null
    expectedOutput?: JsonNullableFilter<"SimulationStep">
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    submissions?: SubmissionListRelationFilter
  }, "id">

  export type SimulationStepOrderByWithAggregationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
    content?: SortOrderInput | SortOrder
    order?: SortOrder
    aiPersona?: SortOrderInput | SortOrder
    expectedOutput?: SortOrderInput | SortOrder
    _count?: SimulationStepCountOrderByAggregateInput
    _avg?: SimulationStepAvgOrderByAggregateInput
    _max?: SimulationStepMaxOrderByAggregateInput
    _min?: SimulationStepMinOrderByAggregateInput
    _sum?: SimulationStepSumOrderByAggregateInput
  }

  export type SimulationStepScalarWhereWithAggregatesInput = {
    AND?: SimulationStepScalarWhereWithAggregatesInput | SimulationStepScalarWhereWithAggregatesInput[]
    OR?: SimulationStepScalarWhereWithAggregatesInput[]
    NOT?: SimulationStepScalarWhereWithAggregatesInput | SimulationStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimulationStep"> | string
    simulationId?: StringWithAggregatesFilter<"SimulationStep"> | string
    type?: EnumStepTypeWithAggregatesFilter<"SimulationStep"> | $Enums.StepType
    title?: StringWithAggregatesFilter<"SimulationStep"> | string
    instructions?: StringWithAggregatesFilter<"SimulationStep"> | string
    content?: JsonNullableWithAggregatesFilter<"SimulationStep">
    order?: IntWithAggregatesFilter<"SimulationStep"> | number
    aiPersona?: StringNullableWithAggregatesFilter<"SimulationStep"> | string | null
    expectedOutput?: JsonNullableWithAggregatesFilter<"SimulationStep">
  }

  export type RubricWhereInput = {
    AND?: RubricWhereInput | RubricWhereInput[]
    OR?: RubricWhereInput[]
    NOT?: RubricWhereInput | RubricWhereInput[]
    id?: StringFilter<"Rubric"> | string
    simulationId?: StringFilter<"Rubric"> | string
    criteria?: JsonFilter<"Rubric">
    weights?: JsonFilter<"Rubric">
    passingScore?: FloatFilter<"Rubric"> | number
    createdAt?: DateTimeFilter<"Rubric"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
  }

  export type RubricOrderByWithRelationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    criteria?: SortOrder
    weights?: SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
    simulation?: SimulationOrderByWithRelationInput
  }

  export type RubricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    simulationId?: string
    AND?: RubricWhereInput | RubricWhereInput[]
    OR?: RubricWhereInput[]
    NOT?: RubricWhereInput | RubricWhereInput[]
    criteria?: JsonFilter<"Rubric">
    weights?: JsonFilter<"Rubric">
    passingScore?: FloatFilter<"Rubric"> | number
    createdAt?: DateTimeFilter<"Rubric"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
  }, "id" | "simulationId">

  export type RubricOrderByWithAggregationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    criteria?: SortOrder
    weights?: SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
    _count?: RubricCountOrderByAggregateInput
    _avg?: RubricAvgOrderByAggregateInput
    _max?: RubricMaxOrderByAggregateInput
    _min?: RubricMinOrderByAggregateInput
    _sum?: RubricSumOrderByAggregateInput
  }

  export type RubricScalarWhereWithAggregatesInput = {
    AND?: RubricScalarWhereWithAggregatesInput | RubricScalarWhereWithAggregatesInput[]
    OR?: RubricScalarWhereWithAggregatesInput[]
    NOT?: RubricScalarWhereWithAggregatesInput | RubricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rubric"> | string
    simulationId?: StringWithAggregatesFilter<"Rubric"> | string
    criteria?: JsonWithAggregatesFilter<"Rubric">
    weights?: JsonWithAggregatesFilter<"Rubric">
    passingScore?: FloatWithAggregatesFilter<"Rubric"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Rubric"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    simulationId?: StringFilter<"Invitation"> | string
    candidateId?: StringNullableFilter<"Invitation"> | string | null
    email?: StringFilter<"Invitation"> | string
    token?: StringFilter<"Invitation"> | string
    status?: EnumInviteStatusFilter<"Invitation"> | $Enums.InviteStatus
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    sentAt?: DateTimeFilter<"Invitation"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    candidate?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    candidateId?: SortOrderInput | SortOrder
    email?: SortOrder
    token?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentAt?: SortOrder
    simulation?: SimulationOrderByWithRelationInput
    candidate?: UserOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    simulationId?: StringFilter<"Invitation"> | string
    candidateId?: StringNullableFilter<"Invitation"> | string | null
    email?: StringFilter<"Invitation"> | string
    status?: EnumInviteStatusFilter<"Invitation"> | $Enums.InviteStatus
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    sentAt?: DateTimeFilter<"Invitation"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    candidate?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "token">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    candidateId?: SortOrderInput | SortOrder
    email?: SortOrder
    token?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentAt?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    simulationId?: StringWithAggregatesFilter<"Invitation"> | string
    candidateId?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    email?: StringWithAggregatesFilter<"Invitation"> | string
    token?: StringWithAggregatesFilter<"Invitation"> | string
    status?: EnumInviteStatusWithAggregatesFilter<"Invitation"> | $Enums.InviteStatus
    expiresAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    sentAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
  }

  export type UserSimulationWhereInput = {
    AND?: UserSimulationWhereInput | UserSimulationWhereInput[]
    OR?: UserSimulationWhereInput[]
    NOT?: UserSimulationWhereInput | UserSimulationWhereInput[]
    id?: StringFilter<"UserSimulation"> | string
    userId?: StringFilter<"UserSimulation"> | string
    simulationId?: StringFilter<"UserSimulation"> | string
    status?: EnumSimulationStatusFilter<"UserSimulation"> | $Enums.SimulationStatus
    startedAt?: DateTimeFilter<"UserSimulation"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserSimulation"> | Date | string | null
    timeSpent?: IntNullableFilter<"UserSimulation"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
  }

  export type UserSimulationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    timeSpent?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    simulation?: SimulationOrderByWithRelationInput
  }

  export type UserSimulationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_simulationId?: UserSimulationUserIdSimulationIdCompoundUniqueInput
    AND?: UserSimulationWhereInput | UserSimulationWhereInput[]
    OR?: UserSimulationWhereInput[]
    NOT?: UserSimulationWhereInput | UserSimulationWhereInput[]
    userId?: StringFilter<"UserSimulation"> | string
    simulationId?: StringFilter<"UserSimulation"> | string
    status?: EnumSimulationStatusFilter<"UserSimulation"> | $Enums.SimulationStatus
    startedAt?: DateTimeFilter<"UserSimulation"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserSimulation"> | Date | string | null
    timeSpent?: IntNullableFilter<"UserSimulation"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
  }, "id" | "userId_simulationId">

  export type UserSimulationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    timeSpent?: SortOrderInput | SortOrder
    _count?: UserSimulationCountOrderByAggregateInput
    _avg?: UserSimulationAvgOrderByAggregateInput
    _max?: UserSimulationMaxOrderByAggregateInput
    _min?: UserSimulationMinOrderByAggregateInput
    _sum?: UserSimulationSumOrderByAggregateInput
  }

  export type UserSimulationScalarWhereWithAggregatesInput = {
    AND?: UserSimulationScalarWhereWithAggregatesInput | UserSimulationScalarWhereWithAggregatesInput[]
    OR?: UserSimulationScalarWhereWithAggregatesInput[]
    NOT?: UserSimulationScalarWhereWithAggregatesInput | UserSimulationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSimulation"> | string
    userId?: StringWithAggregatesFilter<"UserSimulation"> | string
    simulationId?: StringWithAggregatesFilter<"UserSimulation"> | string
    status?: EnumSimulationStatusWithAggregatesFilter<"UserSimulation"> | $Enums.SimulationStatus
    startedAt?: DateTimeWithAggregatesFilter<"UserSimulation"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserSimulation"> | Date | string | null
    timeSpent?: IntNullableWithAggregatesFilter<"UserSimulation"> | number | null
  }

  export type SubmissionWhereInput = {
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    id?: StringFilter<"Submission"> | string
    userId?: StringFilter<"Submission"> | string
    simulationId?: StringFilter<"Submission"> | string
    stepId?: StringFilter<"Submission"> | string
    content?: JsonFilter<"Submission">
    aiFeedback?: JsonNullableFilter<"Submission">
    score?: FloatNullableFilter<"Submission"> | number | null
    completedAt?: DateTimeFilter<"Submission"> | Date | string
    integrityFlags?: StringNullableListFilter<"Submission">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    step?: XOR<SimulationStepScalarRelationFilter, SimulationStepWhereInput>
  }

  export type SubmissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    stepId?: SortOrder
    content?: SortOrder
    aiFeedback?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    completedAt?: SortOrder
    integrityFlags?: SortOrder
    user?: UserOrderByWithRelationInput
    simulation?: SimulationOrderByWithRelationInput
    step?: SimulationStepOrderByWithRelationInput
  }

  export type SubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    userId?: StringFilter<"Submission"> | string
    simulationId?: StringFilter<"Submission"> | string
    stepId?: StringFilter<"Submission"> | string
    content?: JsonFilter<"Submission">
    aiFeedback?: JsonNullableFilter<"Submission">
    score?: FloatNullableFilter<"Submission"> | number | null
    completedAt?: DateTimeFilter<"Submission"> | Date | string
    integrityFlags?: StringNullableListFilter<"Submission">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    step?: XOR<SimulationStepScalarRelationFilter, SimulationStepWhereInput>
  }, "id">

  export type SubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    stepId?: SortOrder
    content?: SortOrder
    aiFeedback?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    completedAt?: SortOrder
    integrityFlags?: SortOrder
    _count?: SubmissionCountOrderByAggregateInput
    _avg?: SubmissionAvgOrderByAggregateInput
    _max?: SubmissionMaxOrderByAggregateInput
    _min?: SubmissionMinOrderByAggregateInput
    _sum?: SubmissionSumOrderByAggregateInput
  }

  export type SubmissionScalarWhereWithAggregatesInput = {
    AND?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    OR?: SubmissionScalarWhereWithAggregatesInput[]
    NOT?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Submission"> | string
    userId?: StringWithAggregatesFilter<"Submission"> | string
    simulationId?: StringWithAggregatesFilter<"Submission"> | string
    stepId?: StringWithAggregatesFilter<"Submission"> | string
    content?: JsonWithAggregatesFilter<"Submission">
    aiFeedback?: JsonNullableWithAggregatesFilter<"Submission">
    score?: FloatNullableWithAggregatesFilter<"Submission"> | number | null
    completedAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string
    integrityFlags?: StringNullableListFilter<"Submission">
  }

  export type AnalyticsWhereInput = {
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    id?: StringFilter<"Analytics"> | string
    simulationId?: StringFilter<"Analytics"> | string
    totalCandidates?: IntFilter<"Analytics"> | number
    avgScore?: FloatFilter<"Analytics"> | number
    completionRate?: FloatFilter<"Analytics"> | number
    diversityData?: JsonNullableFilter<"Analytics">
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
  }

  export type AnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    totalCandidates?: SortOrder
    avgScore?: SortOrder
    completionRate?: SortOrder
    diversityData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    simulation?: SimulationOrderByWithRelationInput
  }

  export type AnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    simulationId?: StringFilter<"Analytics"> | string
    totalCandidates?: IntFilter<"Analytics"> | number
    avgScore?: FloatFilter<"Analytics"> | number
    completionRate?: FloatFilter<"Analytics"> | number
    diversityData?: JsonNullableFilter<"Analytics">
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
  }, "id">

  export type AnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    totalCandidates?: SortOrder
    avgScore?: SortOrder
    completionRate?: SortOrder
    diversityData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsCountOrderByAggregateInput
    _avg?: AnalyticsAvgOrderByAggregateInput
    _max?: AnalyticsMaxOrderByAggregateInput
    _min?: AnalyticsMinOrderByAggregateInput
    _sum?: AnalyticsSumOrderByAggregateInput
  }

  export type AnalyticsScalarWhereWithAggregatesInput = {
    AND?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    OR?: AnalyticsScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Analytics"> | string
    simulationId?: StringWithAggregatesFilter<"Analytics"> | string
    totalCandidates?: IntWithAggregatesFilter<"Analytics"> | number
    avgScore?: FloatWithAggregatesFilter<"Analytics"> | number
    completionRate?: FloatWithAggregatesFilter<"Analytics"> | number
    diversityData?: JsonNullableWithAggregatesFilter<"Analytics">
    createdAt?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSimulations?: SimulationCreateNestedManyWithoutEmployerInput
    simulations?: UserSimulationCreateNestedManyWithoutUserInput
    submissions?: SubmissionCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutCandidateInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSimulations?: SimulationUncheckedCreateNestedManyWithoutEmployerInput
    simulations?: UserSimulationUncheckedCreateNestedManyWithoutUserInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSimulations?: SimulationUpdateManyWithoutEmployerNestedInput
    simulations?: UserSimulationUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutCandidateNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSimulations?: SimulationUncheckedUpdateManyWithoutEmployerNestedInput
    simulations?: UserSimulationUncheckedUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationCreateInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employer: UserCreateNestedOneWithoutCreatedSimulationsInput
    steps?: SimulationStepCreateNestedManyWithoutSimulationInput
    invitations?: InvitationCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionCreateNestedManyWithoutSimulationInput
    rubric?: RubricCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employerId: string
    steps?: SimulationStepUncheckedCreateNestedManyWithoutSimulationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutSimulationInput
    rubric?: RubricUncheckedCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationUncheckedCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: UserUpdateOneRequiredWithoutCreatedSimulationsNestedInput
    steps?: SimulationStepUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employerId?: StringFieldUpdateOperationsInput | string
    steps?: SimulationStepUncheckedUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUncheckedUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUncheckedUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employerId: string
  }

  export type SimulationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employerId?: StringFieldUpdateOperationsInput | string
  }

  export type SimulationStepCreateInput = {
    id?: string
    type: $Enums.StepType
    title: string
    instructions: string
    content?: NullableJsonNullValueInput | InputJsonValue
    order: number
    aiPersona?: string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    simulation: SimulationCreateNestedOneWithoutStepsInput
    submissions?: SubmissionCreateNestedManyWithoutStepInput
  }

  export type SimulationStepUncheckedCreateInput = {
    id?: string
    simulationId: string
    type: $Enums.StepType
    title: string
    instructions: string
    content?: NullableJsonNullValueInput | InputJsonValue
    order: number
    aiPersona?: string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStepInput
  }

  export type SimulationStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    title?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    aiPersona?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    simulation?: SimulationUpdateOneRequiredWithoutStepsNestedInput
    submissions?: SubmissionUpdateManyWithoutStepNestedInput
  }

  export type SimulationStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    title?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    aiPersona?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    submissions?: SubmissionUncheckedUpdateManyWithoutStepNestedInput
  }

  export type SimulationStepCreateManyInput = {
    id?: string
    simulationId: string
    type: $Enums.StepType
    title: string
    instructions: string
    content?: NullableJsonNullValueInput | InputJsonValue
    order: number
    aiPersona?: string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SimulationStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    title?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    aiPersona?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SimulationStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    title?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    aiPersona?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RubricCreateInput = {
    id?: string
    criteria: JsonNullValueInput | InputJsonValue
    weights: JsonNullValueInput | InputJsonValue
    passingScore?: number
    createdAt?: Date | string
    simulation: SimulationCreateNestedOneWithoutRubricInput
  }

  export type RubricUncheckedCreateInput = {
    id?: string
    simulationId: string
    criteria: JsonNullValueInput | InputJsonValue
    weights: JsonNullValueInput | InputJsonValue
    passingScore?: number
    createdAt?: Date | string
  }

  export type RubricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    weights?: JsonNullValueInput | InputJsonValue
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulation?: SimulationUpdateOneRequiredWithoutRubricNestedInput
  }

  export type RubricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    weights?: JsonNullValueInput | InputJsonValue
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RubricCreateManyInput = {
    id?: string
    simulationId: string
    criteria: JsonNullValueInput | InputJsonValue
    weights: JsonNullValueInput | InputJsonValue
    passingScore?: number
    createdAt?: Date | string
  }

  export type RubricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    weights?: JsonNullValueInput | InputJsonValue
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RubricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    weights?: JsonNullValueInput | InputJsonValue
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id?: string
    email: string
    token: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentAt?: Date | string
    simulation: SimulationCreateNestedOneWithoutInvitationsInput
    candidate?: UserCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    simulationId: string
    candidateId?: string | null
    email: string
    token: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentAt?: Date | string
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulation?: SimulationUpdateOneRequiredWithoutInvitationsNestedInput
    candidate?: UserUpdateOneWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    candidateId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateManyInput = {
    id?: string
    simulationId: string
    candidateId?: string | null
    email: string
    token: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentAt?: Date | string
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    candidateId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimulationCreateInput = {
    id?: string
    status?: $Enums.SimulationStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpent?: number | null
    user: UserCreateNestedOneWithoutSimulationsInput
    simulation: SimulationCreateNestedOneWithoutUserSimulationsInput
  }

  export type UserSimulationUncheckedCreateInput = {
    id?: string
    userId: string
    simulationId: string
    status?: $Enums.SimulationStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type UserSimulationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutSimulationsNestedInput
    simulation?: SimulationUpdateOneRequiredWithoutUserSimulationsNestedInput
  }

  export type UserSimulationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSimulationCreateManyInput = {
    id?: string
    userId: string
    simulationId: string
    status?: $Enums.SimulationStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type UserSimulationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSimulationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubmissionCreateInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
    user: UserCreateNestedOneWithoutSubmissionsInput
    simulation: SimulationCreateNestedOneWithoutSubmissionsInput
    step: SimulationStepCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateInput = {
    id?: string
    userId: string
    simulationId: string
    stepId: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
  }

  export type SubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
    simulation?: SimulationUpdateOneRequiredWithoutSubmissionsNestedInput
    step?: SimulationStepUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
  }

  export type SubmissionCreateManyInput = {
    id?: string
    userId: string
    simulationId: string
    stepId: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
  }

  export type SubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
  }

  export type SubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
  }

  export type AnalyticsCreateInput = {
    id?: string
    totalCandidates: number
    avgScore: number
    completionRate: number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    simulation: SimulationCreateNestedOneWithoutAnalyticsInput
  }

  export type AnalyticsUncheckedCreateInput = {
    id?: string
    simulationId: string
    totalCandidates: number
    avgScore: number
    completionRate: number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCandidates?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulation?: SimulationUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type AnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    totalCandidates?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCreateManyInput = {
    id?: string
    simulationId: string
    totalCandidates: number
    avgScore: number
    completionRate: number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCandidates?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    totalCandidates?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SimulationListRelationFilter = {
    every?: SimulationWhereInput
    some?: SimulationWhereInput
    none?: SimulationWhereInput
  }

  export type UserSimulationListRelationFilter = {
    every?: UserSimulationWhereInput
    some?: UserSimulationWhereInput
    none?: UserSimulationWhereInput
  }

  export type SubmissionListRelationFilter = {
    every?: SubmissionWhereInput
    some?: SubmissionWhereInput
    none?: SubmissionWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SimulationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSimulationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SimulationStepListRelationFilter = {
    every?: SimulationStepWhereInput
    some?: SimulationStepWhereInput
    none?: SimulationStepWhereInput
  }

  export type RubricNullableScalarRelationFilter = {
    is?: RubricWhereInput | null
    isNot?: RubricWhereInput | null
  }

  export type AnalyticsListRelationFilter = {
    every?: AnalyticsWhereInput
    some?: AnalyticsWhereInput
    none?: AnalyticsWhereInput
  }

  export type SimulationStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimulationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    isPublished?: SortOrder
    isBlindMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employerId?: SortOrder
  }

  export type SimulationAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type SimulationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    isPublished?: SortOrder
    isBlindMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employerId?: SortOrder
  }

  export type SimulationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    isPublished?: SortOrder
    isBlindMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employerId?: SortOrder
  }

  export type SimulationSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StepType | EnumStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStepTypeFilter<$PrismaModel> | $Enums.StepType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SimulationScalarRelationFilter = {
    is?: SimulationWhereInput
    isNot?: SimulationWhereInput
  }

  export type SimulationStepCountOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
    content?: SortOrder
    order?: SortOrder
    aiPersona?: SortOrder
    expectedOutput?: SortOrder
  }

  export type SimulationStepAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SimulationStepMaxOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
    order?: SortOrder
    aiPersona?: SortOrder
  }

  export type SimulationStepMinOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
    order?: SortOrder
    aiPersona?: SortOrder
  }

  export type SimulationStepSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepType | EnumStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.StepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepTypeFilter<$PrismaModel>
    _max?: NestedEnumStepTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RubricCountOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    criteria?: SortOrder
    weights?: SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
  }

  export type RubricAvgOrderByAggregateInput = {
    passingScore?: SortOrder
  }

  export type RubricMaxOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
  }

  export type RubricMinOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
  }

  export type RubricSumOrderByAggregateInput = {
    passingScore?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    candidateId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentAt?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    candidateId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentAt?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    candidateId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    sentAt?: SortOrder
  }

  export type EnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type EnumSimulationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusFilter<$PrismaModel> | $Enums.SimulationStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserSimulationUserIdSimulationIdCompoundUniqueInput = {
    userId: string
    simulationId: string
  }

  export type UserSimulationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    timeSpent?: SortOrder
  }

  export type UserSimulationAvgOrderByAggregateInput = {
    timeSpent?: SortOrder
  }

  export type UserSimulationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    timeSpent?: SortOrder
  }

  export type UserSimulationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    timeSpent?: SortOrder
  }

  export type UserSimulationSumOrderByAggregateInput = {
    timeSpent?: SortOrder
  }

  export type EnumSimulationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimulationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimulationStatusFilter<$PrismaModel>
    _max?: NestedEnumSimulationStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SimulationStepScalarRelationFilter = {
    is?: SimulationStepWhereInput
    isNot?: SimulationStepWhereInput
  }

  export type SubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    stepId?: SortOrder
    content?: SortOrder
    aiFeedback?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
    integrityFlags?: SortOrder
  }

  export type SubmissionAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type SubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    stepId?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
  }

  export type SubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    simulationId?: SortOrder
    stepId?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
  }

  export type SubmissionSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    totalCandidates?: SortOrder
    avgScore?: SortOrder
    completionRate?: SortOrder
    diversityData?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAvgOrderByAggregateInput = {
    totalCandidates?: SortOrder
    avgScore?: SortOrder
    completionRate?: SortOrder
  }

  export type AnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    totalCandidates?: SortOrder
    avgScore?: SortOrder
    completionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    totalCandidates?: SortOrder
    avgScore?: SortOrder
    completionRate?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsSumOrderByAggregateInput = {
    totalCandidates?: SortOrder
    avgScore?: SortOrder
    completionRate?: SortOrder
  }

  export type SimulationCreateNestedManyWithoutEmployerInput = {
    create?: XOR<SimulationCreateWithoutEmployerInput, SimulationUncheckedCreateWithoutEmployerInput> | SimulationCreateWithoutEmployerInput[] | SimulationUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutEmployerInput | SimulationCreateOrConnectWithoutEmployerInput[]
    createMany?: SimulationCreateManyEmployerInputEnvelope
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
  }

  export type UserSimulationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSimulationCreateWithoutUserInput, UserSimulationUncheckedCreateWithoutUserInput> | UserSimulationCreateWithoutUserInput[] | UserSimulationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSimulationCreateOrConnectWithoutUserInput | UserSimulationCreateOrConnectWithoutUserInput[]
    createMany?: UserSimulationCreateManyUserInputEnvelope
    connect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
  }

  export type SubmissionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutCandidateInput = {
    create?: XOR<InvitationCreateWithoutCandidateInput, InvitationUncheckedCreateWithoutCandidateInput> | InvitationCreateWithoutCandidateInput[] | InvitationUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutCandidateInput | InvitationCreateOrConnectWithoutCandidateInput[]
    createMany?: InvitationCreateManyCandidateInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type SimulationUncheckedCreateNestedManyWithoutEmployerInput = {
    create?: XOR<SimulationCreateWithoutEmployerInput, SimulationUncheckedCreateWithoutEmployerInput> | SimulationCreateWithoutEmployerInput[] | SimulationUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutEmployerInput | SimulationCreateOrConnectWithoutEmployerInput[]
    createMany?: SimulationCreateManyEmployerInputEnvelope
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
  }

  export type UserSimulationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSimulationCreateWithoutUserInput, UserSimulationUncheckedCreateWithoutUserInput> | UserSimulationCreateWithoutUserInput[] | UserSimulationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSimulationCreateOrConnectWithoutUserInput | UserSimulationCreateOrConnectWithoutUserInput[]
    createMany?: UserSimulationCreateManyUserInputEnvelope
    connect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
  }

  export type SubmissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutCandidateInput = {
    create?: XOR<InvitationCreateWithoutCandidateInput, InvitationUncheckedCreateWithoutCandidateInput> | InvitationCreateWithoutCandidateInput[] | InvitationUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutCandidateInput | InvitationCreateOrConnectWithoutCandidateInput[]
    createMany?: InvitationCreateManyCandidateInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SimulationUpdateManyWithoutEmployerNestedInput = {
    create?: XOR<SimulationCreateWithoutEmployerInput, SimulationUncheckedCreateWithoutEmployerInput> | SimulationCreateWithoutEmployerInput[] | SimulationUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutEmployerInput | SimulationCreateOrConnectWithoutEmployerInput[]
    upsert?: SimulationUpsertWithWhereUniqueWithoutEmployerInput | SimulationUpsertWithWhereUniqueWithoutEmployerInput[]
    createMany?: SimulationCreateManyEmployerInputEnvelope
    set?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    disconnect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    delete?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    update?: SimulationUpdateWithWhereUniqueWithoutEmployerInput | SimulationUpdateWithWhereUniqueWithoutEmployerInput[]
    updateMany?: SimulationUpdateManyWithWhereWithoutEmployerInput | SimulationUpdateManyWithWhereWithoutEmployerInput[]
    deleteMany?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
  }

  export type UserSimulationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSimulationCreateWithoutUserInput, UserSimulationUncheckedCreateWithoutUserInput> | UserSimulationCreateWithoutUserInput[] | UserSimulationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSimulationCreateOrConnectWithoutUserInput | UserSimulationCreateOrConnectWithoutUserInput[]
    upsert?: UserSimulationUpsertWithWhereUniqueWithoutUserInput | UserSimulationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSimulationCreateManyUserInputEnvelope
    set?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    disconnect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    delete?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    connect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    update?: UserSimulationUpdateWithWhereUniqueWithoutUserInput | UserSimulationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSimulationUpdateManyWithWhereWithoutUserInput | UserSimulationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSimulationScalarWhereInput | UserSimulationScalarWhereInput[]
  }

  export type SubmissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutUserInput | SubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutUserInput | SubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutUserInput | SubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<InvitationCreateWithoutCandidateInput, InvitationUncheckedCreateWithoutCandidateInput> | InvitationCreateWithoutCandidateInput[] | InvitationUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutCandidateInput | InvitationCreateOrConnectWithoutCandidateInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutCandidateInput | InvitationUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: InvitationCreateManyCandidateInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutCandidateInput | InvitationUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutCandidateInput | InvitationUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type SimulationUncheckedUpdateManyWithoutEmployerNestedInput = {
    create?: XOR<SimulationCreateWithoutEmployerInput, SimulationUncheckedCreateWithoutEmployerInput> | SimulationCreateWithoutEmployerInput[] | SimulationUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutEmployerInput | SimulationCreateOrConnectWithoutEmployerInput[]
    upsert?: SimulationUpsertWithWhereUniqueWithoutEmployerInput | SimulationUpsertWithWhereUniqueWithoutEmployerInput[]
    createMany?: SimulationCreateManyEmployerInputEnvelope
    set?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    disconnect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    delete?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    update?: SimulationUpdateWithWhereUniqueWithoutEmployerInput | SimulationUpdateWithWhereUniqueWithoutEmployerInput[]
    updateMany?: SimulationUpdateManyWithWhereWithoutEmployerInput | SimulationUpdateManyWithWhereWithoutEmployerInput[]
    deleteMany?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
  }

  export type UserSimulationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSimulationCreateWithoutUserInput, UserSimulationUncheckedCreateWithoutUserInput> | UserSimulationCreateWithoutUserInput[] | UserSimulationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSimulationCreateOrConnectWithoutUserInput | UserSimulationCreateOrConnectWithoutUserInput[]
    upsert?: UserSimulationUpsertWithWhereUniqueWithoutUserInput | UserSimulationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSimulationCreateManyUserInputEnvelope
    set?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    disconnect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    delete?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    connect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    update?: UserSimulationUpdateWithWhereUniqueWithoutUserInput | UserSimulationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSimulationUpdateManyWithWhereWithoutUserInput | UserSimulationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSimulationScalarWhereInput | UserSimulationScalarWhereInput[]
  }

  export type SubmissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutUserInput | SubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutUserInput | SubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutUserInput | SubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<InvitationCreateWithoutCandidateInput, InvitationUncheckedCreateWithoutCandidateInput> | InvitationCreateWithoutCandidateInput[] | InvitationUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutCandidateInput | InvitationCreateOrConnectWithoutCandidateInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutCandidateInput | InvitationUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: InvitationCreateManyCandidateInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutCandidateInput | InvitationUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutCandidateInput | InvitationUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedSimulationsInput = {
    create?: XOR<UserCreateWithoutCreatedSimulationsInput, UserUncheckedCreateWithoutCreatedSimulationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSimulationsInput
    connect?: UserWhereUniqueInput
  }

  export type SimulationStepCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SimulationStepCreateWithoutSimulationInput, SimulationStepUncheckedCreateWithoutSimulationInput> | SimulationStepCreateWithoutSimulationInput[] | SimulationStepUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationStepCreateOrConnectWithoutSimulationInput | SimulationStepCreateOrConnectWithoutSimulationInput[]
    createMany?: SimulationStepCreateManySimulationInputEnvelope
    connect?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutSimulationInput = {
    create?: XOR<InvitationCreateWithoutSimulationInput, InvitationUncheckedCreateWithoutSimulationInput> | InvitationCreateWithoutSimulationInput[] | InvitationUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutSimulationInput | InvitationCreateOrConnectWithoutSimulationInput[]
    createMany?: InvitationCreateManySimulationInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type SubmissionCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SubmissionCreateWithoutSimulationInput, SubmissionUncheckedCreateWithoutSimulationInput> | SubmissionCreateWithoutSimulationInput[] | SubmissionUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutSimulationInput | SubmissionCreateOrConnectWithoutSimulationInput[]
    createMany?: SubmissionCreateManySimulationInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type RubricCreateNestedOneWithoutSimulationInput = {
    create?: XOR<RubricCreateWithoutSimulationInput, RubricUncheckedCreateWithoutSimulationInput>
    connectOrCreate?: RubricCreateOrConnectWithoutSimulationInput
    connect?: RubricWhereUniqueInput
  }

  export type UserSimulationCreateNestedManyWithoutSimulationInput = {
    create?: XOR<UserSimulationCreateWithoutSimulationInput, UserSimulationUncheckedCreateWithoutSimulationInput> | UserSimulationCreateWithoutSimulationInput[] | UserSimulationUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: UserSimulationCreateOrConnectWithoutSimulationInput | UserSimulationCreateOrConnectWithoutSimulationInput[]
    createMany?: UserSimulationCreateManySimulationInputEnvelope
    connect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
  }

  export type AnalyticsCreateNestedManyWithoutSimulationInput = {
    create?: XOR<AnalyticsCreateWithoutSimulationInput, AnalyticsUncheckedCreateWithoutSimulationInput> | AnalyticsCreateWithoutSimulationInput[] | AnalyticsUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutSimulationInput | AnalyticsCreateOrConnectWithoutSimulationInput[]
    createMany?: AnalyticsCreateManySimulationInputEnvelope
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
  }

  export type SimulationStepUncheckedCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SimulationStepCreateWithoutSimulationInput, SimulationStepUncheckedCreateWithoutSimulationInput> | SimulationStepCreateWithoutSimulationInput[] | SimulationStepUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationStepCreateOrConnectWithoutSimulationInput | SimulationStepCreateOrConnectWithoutSimulationInput[]
    createMany?: SimulationStepCreateManySimulationInputEnvelope
    connect?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutSimulationInput = {
    create?: XOR<InvitationCreateWithoutSimulationInput, InvitationUncheckedCreateWithoutSimulationInput> | InvitationCreateWithoutSimulationInput[] | InvitationUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutSimulationInput | InvitationCreateOrConnectWithoutSimulationInput[]
    createMany?: InvitationCreateManySimulationInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type SubmissionUncheckedCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SubmissionCreateWithoutSimulationInput, SubmissionUncheckedCreateWithoutSimulationInput> | SubmissionCreateWithoutSimulationInput[] | SubmissionUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutSimulationInput | SubmissionCreateOrConnectWithoutSimulationInput[]
    createMany?: SubmissionCreateManySimulationInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type RubricUncheckedCreateNestedOneWithoutSimulationInput = {
    create?: XOR<RubricCreateWithoutSimulationInput, RubricUncheckedCreateWithoutSimulationInput>
    connectOrCreate?: RubricCreateOrConnectWithoutSimulationInput
    connect?: RubricWhereUniqueInput
  }

  export type UserSimulationUncheckedCreateNestedManyWithoutSimulationInput = {
    create?: XOR<UserSimulationCreateWithoutSimulationInput, UserSimulationUncheckedCreateWithoutSimulationInput> | UserSimulationCreateWithoutSimulationInput[] | UserSimulationUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: UserSimulationCreateOrConnectWithoutSimulationInput | UserSimulationCreateOrConnectWithoutSimulationInput[]
    createMany?: UserSimulationCreateManySimulationInputEnvelope
    connect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
  }

  export type AnalyticsUncheckedCreateNestedManyWithoutSimulationInput = {
    create?: XOR<AnalyticsCreateWithoutSimulationInput, AnalyticsUncheckedCreateWithoutSimulationInput> | AnalyticsCreateWithoutSimulationInput[] | AnalyticsUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutSimulationInput | AnalyticsCreateOrConnectWithoutSimulationInput[]
    createMany?: AnalyticsCreateManySimulationInputEnvelope
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCreatedSimulationsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSimulationsInput, UserUncheckedCreateWithoutCreatedSimulationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSimulationsInput
    upsert?: UserUpsertWithoutCreatedSimulationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSimulationsInput, UserUpdateWithoutCreatedSimulationsInput>, UserUncheckedUpdateWithoutCreatedSimulationsInput>
  }

  export type SimulationStepUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SimulationStepCreateWithoutSimulationInput, SimulationStepUncheckedCreateWithoutSimulationInput> | SimulationStepCreateWithoutSimulationInput[] | SimulationStepUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationStepCreateOrConnectWithoutSimulationInput | SimulationStepCreateOrConnectWithoutSimulationInput[]
    upsert?: SimulationStepUpsertWithWhereUniqueWithoutSimulationInput | SimulationStepUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SimulationStepCreateManySimulationInputEnvelope
    set?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
    disconnect?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
    delete?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
    connect?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
    update?: SimulationStepUpdateWithWhereUniqueWithoutSimulationInput | SimulationStepUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SimulationStepUpdateManyWithWhereWithoutSimulationInput | SimulationStepUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SimulationStepScalarWhereInput | SimulationStepScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<InvitationCreateWithoutSimulationInput, InvitationUncheckedCreateWithoutSimulationInput> | InvitationCreateWithoutSimulationInput[] | InvitationUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutSimulationInput | InvitationCreateOrConnectWithoutSimulationInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutSimulationInput | InvitationUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: InvitationCreateManySimulationInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutSimulationInput | InvitationUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutSimulationInput | InvitationUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type SubmissionUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SubmissionCreateWithoutSimulationInput, SubmissionUncheckedCreateWithoutSimulationInput> | SubmissionCreateWithoutSimulationInput[] | SubmissionUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutSimulationInput | SubmissionCreateOrConnectWithoutSimulationInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutSimulationInput | SubmissionUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SubmissionCreateManySimulationInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutSimulationInput | SubmissionUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutSimulationInput | SubmissionUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type RubricUpdateOneWithoutSimulationNestedInput = {
    create?: XOR<RubricCreateWithoutSimulationInput, RubricUncheckedCreateWithoutSimulationInput>
    connectOrCreate?: RubricCreateOrConnectWithoutSimulationInput
    upsert?: RubricUpsertWithoutSimulationInput
    disconnect?: RubricWhereInput | boolean
    delete?: RubricWhereInput | boolean
    connect?: RubricWhereUniqueInput
    update?: XOR<XOR<RubricUpdateToOneWithWhereWithoutSimulationInput, RubricUpdateWithoutSimulationInput>, RubricUncheckedUpdateWithoutSimulationInput>
  }

  export type UserSimulationUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<UserSimulationCreateWithoutSimulationInput, UserSimulationUncheckedCreateWithoutSimulationInput> | UserSimulationCreateWithoutSimulationInput[] | UserSimulationUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: UserSimulationCreateOrConnectWithoutSimulationInput | UserSimulationCreateOrConnectWithoutSimulationInput[]
    upsert?: UserSimulationUpsertWithWhereUniqueWithoutSimulationInput | UserSimulationUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: UserSimulationCreateManySimulationInputEnvelope
    set?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    disconnect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    delete?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    connect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    update?: UserSimulationUpdateWithWhereUniqueWithoutSimulationInput | UserSimulationUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: UserSimulationUpdateManyWithWhereWithoutSimulationInput | UserSimulationUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: UserSimulationScalarWhereInput | UserSimulationScalarWhereInput[]
  }

  export type AnalyticsUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<AnalyticsCreateWithoutSimulationInput, AnalyticsUncheckedCreateWithoutSimulationInput> | AnalyticsCreateWithoutSimulationInput[] | AnalyticsUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutSimulationInput | AnalyticsCreateOrConnectWithoutSimulationInput[]
    upsert?: AnalyticsUpsertWithWhereUniqueWithoutSimulationInput | AnalyticsUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: AnalyticsCreateManySimulationInputEnvelope
    set?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    disconnect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    delete?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    update?: AnalyticsUpdateWithWhereUniqueWithoutSimulationInput | AnalyticsUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: AnalyticsUpdateManyWithWhereWithoutSimulationInput | AnalyticsUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
  }

  export type SimulationStepUncheckedUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SimulationStepCreateWithoutSimulationInput, SimulationStepUncheckedCreateWithoutSimulationInput> | SimulationStepCreateWithoutSimulationInput[] | SimulationStepUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationStepCreateOrConnectWithoutSimulationInput | SimulationStepCreateOrConnectWithoutSimulationInput[]
    upsert?: SimulationStepUpsertWithWhereUniqueWithoutSimulationInput | SimulationStepUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SimulationStepCreateManySimulationInputEnvelope
    set?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
    disconnect?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
    delete?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
    connect?: SimulationStepWhereUniqueInput | SimulationStepWhereUniqueInput[]
    update?: SimulationStepUpdateWithWhereUniqueWithoutSimulationInput | SimulationStepUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SimulationStepUpdateManyWithWhereWithoutSimulationInput | SimulationStepUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SimulationStepScalarWhereInput | SimulationStepScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<InvitationCreateWithoutSimulationInput, InvitationUncheckedCreateWithoutSimulationInput> | InvitationCreateWithoutSimulationInput[] | InvitationUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutSimulationInput | InvitationCreateOrConnectWithoutSimulationInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutSimulationInput | InvitationUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: InvitationCreateManySimulationInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutSimulationInput | InvitationUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutSimulationInput | InvitationUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type SubmissionUncheckedUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SubmissionCreateWithoutSimulationInput, SubmissionUncheckedCreateWithoutSimulationInput> | SubmissionCreateWithoutSimulationInput[] | SubmissionUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutSimulationInput | SubmissionCreateOrConnectWithoutSimulationInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutSimulationInput | SubmissionUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SubmissionCreateManySimulationInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutSimulationInput | SubmissionUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutSimulationInput | SubmissionUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type RubricUncheckedUpdateOneWithoutSimulationNestedInput = {
    create?: XOR<RubricCreateWithoutSimulationInput, RubricUncheckedCreateWithoutSimulationInput>
    connectOrCreate?: RubricCreateOrConnectWithoutSimulationInput
    upsert?: RubricUpsertWithoutSimulationInput
    disconnect?: RubricWhereInput | boolean
    delete?: RubricWhereInput | boolean
    connect?: RubricWhereUniqueInput
    update?: XOR<XOR<RubricUpdateToOneWithWhereWithoutSimulationInput, RubricUpdateWithoutSimulationInput>, RubricUncheckedUpdateWithoutSimulationInput>
  }

  export type UserSimulationUncheckedUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<UserSimulationCreateWithoutSimulationInput, UserSimulationUncheckedCreateWithoutSimulationInput> | UserSimulationCreateWithoutSimulationInput[] | UserSimulationUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: UserSimulationCreateOrConnectWithoutSimulationInput | UserSimulationCreateOrConnectWithoutSimulationInput[]
    upsert?: UserSimulationUpsertWithWhereUniqueWithoutSimulationInput | UserSimulationUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: UserSimulationCreateManySimulationInputEnvelope
    set?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    disconnect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    delete?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    connect?: UserSimulationWhereUniqueInput | UserSimulationWhereUniqueInput[]
    update?: UserSimulationUpdateWithWhereUniqueWithoutSimulationInput | UserSimulationUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: UserSimulationUpdateManyWithWhereWithoutSimulationInput | UserSimulationUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: UserSimulationScalarWhereInput | UserSimulationScalarWhereInput[]
  }

  export type AnalyticsUncheckedUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<AnalyticsCreateWithoutSimulationInput, AnalyticsUncheckedCreateWithoutSimulationInput> | AnalyticsCreateWithoutSimulationInput[] | AnalyticsUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutSimulationInput | AnalyticsCreateOrConnectWithoutSimulationInput[]
    upsert?: AnalyticsUpsertWithWhereUniqueWithoutSimulationInput | AnalyticsUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: AnalyticsCreateManySimulationInputEnvelope
    set?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    disconnect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    delete?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    update?: AnalyticsUpdateWithWhereUniqueWithoutSimulationInput | AnalyticsUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: AnalyticsUpdateManyWithWhereWithoutSimulationInput | AnalyticsUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
  }

  export type SimulationCreateNestedOneWithoutStepsInput = {
    create?: XOR<SimulationCreateWithoutStepsInput, SimulationUncheckedCreateWithoutStepsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutStepsInput
    connect?: SimulationWhereUniqueInput
  }

  export type SubmissionCreateNestedManyWithoutStepInput = {
    create?: XOR<SubmissionCreateWithoutStepInput, SubmissionUncheckedCreateWithoutStepInput> | SubmissionCreateWithoutStepInput[] | SubmissionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutStepInput | SubmissionCreateOrConnectWithoutStepInput[]
    createMany?: SubmissionCreateManyStepInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type SubmissionUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<SubmissionCreateWithoutStepInput, SubmissionUncheckedCreateWithoutStepInput> | SubmissionCreateWithoutStepInput[] | SubmissionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutStepInput | SubmissionCreateOrConnectWithoutStepInput[]
    createMany?: SubmissionCreateManyStepInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type EnumStepTypeFieldUpdateOperationsInput = {
    set?: $Enums.StepType
  }

  export type SimulationUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<SimulationCreateWithoutStepsInput, SimulationUncheckedCreateWithoutStepsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutStepsInput
    upsert?: SimulationUpsertWithoutStepsInput
    connect?: SimulationWhereUniqueInput
    update?: XOR<XOR<SimulationUpdateToOneWithWhereWithoutStepsInput, SimulationUpdateWithoutStepsInput>, SimulationUncheckedUpdateWithoutStepsInput>
  }

  export type SubmissionUpdateManyWithoutStepNestedInput = {
    create?: XOR<SubmissionCreateWithoutStepInput, SubmissionUncheckedCreateWithoutStepInput> | SubmissionCreateWithoutStepInput[] | SubmissionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutStepInput | SubmissionCreateOrConnectWithoutStepInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutStepInput | SubmissionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: SubmissionCreateManyStepInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutStepInput | SubmissionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutStepInput | SubmissionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type SubmissionUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<SubmissionCreateWithoutStepInput, SubmissionUncheckedCreateWithoutStepInput> | SubmissionCreateWithoutStepInput[] | SubmissionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutStepInput | SubmissionCreateOrConnectWithoutStepInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutStepInput | SubmissionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: SubmissionCreateManyStepInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutStepInput | SubmissionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutStepInput | SubmissionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type SimulationCreateNestedOneWithoutRubricInput = {
    create?: XOR<SimulationCreateWithoutRubricInput, SimulationUncheckedCreateWithoutRubricInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutRubricInput
    connect?: SimulationWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SimulationUpdateOneRequiredWithoutRubricNestedInput = {
    create?: XOR<SimulationCreateWithoutRubricInput, SimulationUncheckedCreateWithoutRubricInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutRubricInput
    upsert?: SimulationUpsertWithoutRubricInput
    connect?: SimulationWhereUniqueInput
    update?: XOR<XOR<SimulationUpdateToOneWithWhereWithoutRubricInput, SimulationUpdateWithoutRubricInput>, SimulationUncheckedUpdateWithoutRubricInput>
  }

  export type SimulationCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<SimulationCreateWithoutInvitationsInput, SimulationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutInvitationsInput
    connect?: SimulationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInviteStatusFieldUpdateOperationsInput = {
    set?: $Enums.InviteStatus
  }

  export type SimulationUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<SimulationCreateWithoutInvitationsInput, SimulationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutInvitationsInput
    upsert?: SimulationUpsertWithoutInvitationsInput
    connect?: SimulationWhereUniqueInput
    update?: XOR<XOR<SimulationUpdateToOneWithWhereWithoutInvitationsInput, SimulationUpdateWithoutInvitationsInput>, SimulationUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneWithoutInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    upsert?: UserUpsertWithoutInvitationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsInput, UserUpdateWithoutInvitationsInput>, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutSimulationsInput = {
    create?: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSimulationsInput
    connect?: UserWhereUniqueInput
  }

  export type SimulationCreateNestedOneWithoutUserSimulationsInput = {
    create?: XOR<SimulationCreateWithoutUserSimulationsInput, SimulationUncheckedCreateWithoutUserSimulationsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutUserSimulationsInput
    connect?: SimulationWhereUniqueInput
  }

  export type EnumSimulationStatusFieldUpdateOperationsInput = {
    set?: $Enums.SimulationStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSimulationsNestedInput = {
    create?: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSimulationsInput
    upsert?: UserUpsertWithoutSimulationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSimulationsInput, UserUpdateWithoutSimulationsInput>, UserUncheckedUpdateWithoutSimulationsInput>
  }

  export type SimulationUpdateOneRequiredWithoutUserSimulationsNestedInput = {
    create?: XOR<SimulationCreateWithoutUserSimulationsInput, SimulationUncheckedCreateWithoutUserSimulationsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutUserSimulationsInput
    upsert?: SimulationUpsertWithoutUserSimulationsInput
    connect?: SimulationWhereUniqueInput
    update?: XOR<XOR<SimulationUpdateToOneWithWhereWithoutUserSimulationsInput, SimulationUpdateWithoutUserSimulationsInput>, SimulationUncheckedUpdateWithoutUserSimulationsInput>
  }

  export type SubmissionCreateintegrityFlagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type SimulationCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<SimulationCreateWithoutSubmissionsInput, SimulationUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutSubmissionsInput
    connect?: SimulationWhereUniqueInput
  }

  export type SimulationStepCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<SimulationStepCreateWithoutSubmissionsInput, SimulationStepUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: SimulationStepCreateOrConnectWithoutSubmissionsInput
    connect?: SimulationStepWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SubmissionUpdateintegrityFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    upsert?: UserUpsertWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubmissionsInput, UserUpdateWithoutSubmissionsInput>, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type SimulationUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<SimulationCreateWithoutSubmissionsInput, SimulationUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutSubmissionsInput
    upsert?: SimulationUpsertWithoutSubmissionsInput
    connect?: SimulationWhereUniqueInput
    update?: XOR<XOR<SimulationUpdateToOneWithWhereWithoutSubmissionsInput, SimulationUpdateWithoutSubmissionsInput>, SimulationUncheckedUpdateWithoutSubmissionsInput>
  }

  export type SimulationStepUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<SimulationStepCreateWithoutSubmissionsInput, SimulationStepUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: SimulationStepCreateOrConnectWithoutSubmissionsInput
    upsert?: SimulationStepUpsertWithoutSubmissionsInput
    connect?: SimulationStepWhereUniqueInput
    update?: XOR<XOR<SimulationStepUpdateToOneWithWhereWithoutSubmissionsInput, SimulationStepUpdateWithoutSubmissionsInput>, SimulationStepUncheckedUpdateWithoutSubmissionsInput>
  }

  export type SimulationCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<SimulationCreateWithoutAnalyticsInput, SimulationUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutAnalyticsInput
    connect?: SimulationWhereUniqueInput
  }

  export type SimulationUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<SimulationCreateWithoutAnalyticsInput, SimulationUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutAnalyticsInput
    upsert?: SimulationUpsertWithoutAnalyticsInput
    connect?: SimulationWhereUniqueInput
    update?: XOR<XOR<SimulationUpdateToOneWithWhereWithoutAnalyticsInput, SimulationUpdateWithoutAnalyticsInput>, SimulationUncheckedUpdateWithoutAnalyticsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StepType | EnumStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStepTypeFilter<$PrismaModel> | $Enums.StepType
  }

  export type NestedEnumStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepType | EnumStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepType[] | ListEnumStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.StepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepTypeFilter<$PrismaModel>
    _max?: NestedEnumStepTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type NestedEnumSimulationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusFilter<$PrismaModel> | $Enums.SimulationStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSimulationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimulationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimulationStatusFilter<$PrismaModel>
    _max?: NestedEnumSimulationStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SimulationCreateWithoutEmployerInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: SimulationStepCreateNestedManyWithoutSimulationInput
    invitations?: InvitationCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionCreateNestedManyWithoutSimulationInput
    rubric?: RubricCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutEmployerInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: SimulationStepUncheckedCreateNestedManyWithoutSimulationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutSimulationInput
    rubric?: RubricUncheckedCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationUncheckedCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutEmployerInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutEmployerInput, SimulationUncheckedCreateWithoutEmployerInput>
  }

  export type SimulationCreateManyEmployerInputEnvelope = {
    data: SimulationCreateManyEmployerInput | SimulationCreateManyEmployerInput[]
    skipDuplicates?: boolean
  }

  export type UserSimulationCreateWithoutUserInput = {
    id?: string
    status?: $Enums.SimulationStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpent?: number | null
    simulation: SimulationCreateNestedOneWithoutUserSimulationsInput
  }

  export type UserSimulationUncheckedCreateWithoutUserInput = {
    id?: string
    simulationId: string
    status?: $Enums.SimulationStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type UserSimulationCreateOrConnectWithoutUserInput = {
    where: UserSimulationWhereUniqueInput
    create: XOR<UserSimulationCreateWithoutUserInput, UserSimulationUncheckedCreateWithoutUserInput>
  }

  export type UserSimulationCreateManyUserInputEnvelope = {
    data: UserSimulationCreateManyUserInput | UserSimulationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionCreateWithoutUserInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
    simulation: SimulationCreateNestedOneWithoutSubmissionsInput
    step: SimulationStepCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateWithoutUserInput = {
    id?: string
    simulationId: string
    stepId: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
  }

  export type SubmissionCreateOrConnectWithoutUserInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput>
  }

  export type SubmissionCreateManyUserInputEnvelope = {
    data: SubmissionCreateManyUserInput | SubmissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutCandidateInput = {
    id?: string
    email: string
    token: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentAt?: Date | string
    simulation: SimulationCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutCandidateInput = {
    id?: string
    simulationId: string
    email: string
    token: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentAt?: Date | string
  }

  export type InvitationCreateOrConnectWithoutCandidateInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutCandidateInput, InvitationUncheckedCreateWithoutCandidateInput>
  }

  export type InvitationCreateManyCandidateInputEnvelope = {
    data: InvitationCreateManyCandidateInput | InvitationCreateManyCandidateInput[]
    skipDuplicates?: boolean
  }

  export type SimulationUpsertWithWhereUniqueWithoutEmployerInput = {
    where: SimulationWhereUniqueInput
    update: XOR<SimulationUpdateWithoutEmployerInput, SimulationUncheckedUpdateWithoutEmployerInput>
    create: XOR<SimulationCreateWithoutEmployerInput, SimulationUncheckedCreateWithoutEmployerInput>
  }

  export type SimulationUpdateWithWhereUniqueWithoutEmployerInput = {
    where: SimulationWhereUniqueInput
    data: XOR<SimulationUpdateWithoutEmployerInput, SimulationUncheckedUpdateWithoutEmployerInput>
  }

  export type SimulationUpdateManyWithWhereWithoutEmployerInput = {
    where: SimulationScalarWhereInput
    data: XOR<SimulationUpdateManyMutationInput, SimulationUncheckedUpdateManyWithoutEmployerInput>
  }

  export type SimulationScalarWhereInput = {
    AND?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
    OR?: SimulationScalarWhereInput[]
    NOT?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
    id?: StringFilter<"Simulation"> | string
    title?: StringFilter<"Simulation"> | string
    description?: StringNullableFilter<"Simulation"> | string | null
    duration?: IntFilter<"Simulation"> | number
    isPublished?: BoolFilter<"Simulation"> | boolean
    isBlindMode?: BoolFilter<"Simulation"> | boolean
    createdAt?: DateTimeFilter<"Simulation"> | Date | string
    updatedAt?: DateTimeFilter<"Simulation"> | Date | string
    employerId?: StringFilter<"Simulation"> | string
  }

  export type UserSimulationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSimulationWhereUniqueInput
    update: XOR<UserSimulationUpdateWithoutUserInput, UserSimulationUncheckedUpdateWithoutUserInput>
    create: XOR<UserSimulationCreateWithoutUserInput, UserSimulationUncheckedCreateWithoutUserInput>
  }

  export type UserSimulationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSimulationWhereUniqueInput
    data: XOR<UserSimulationUpdateWithoutUserInput, UserSimulationUncheckedUpdateWithoutUserInput>
  }

  export type UserSimulationUpdateManyWithWhereWithoutUserInput = {
    where: UserSimulationScalarWhereInput
    data: XOR<UserSimulationUpdateManyMutationInput, UserSimulationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSimulationScalarWhereInput = {
    AND?: UserSimulationScalarWhereInput | UserSimulationScalarWhereInput[]
    OR?: UserSimulationScalarWhereInput[]
    NOT?: UserSimulationScalarWhereInput | UserSimulationScalarWhereInput[]
    id?: StringFilter<"UserSimulation"> | string
    userId?: StringFilter<"UserSimulation"> | string
    simulationId?: StringFilter<"UserSimulation"> | string
    status?: EnumSimulationStatusFilter<"UserSimulation"> | $Enums.SimulationStatus
    startedAt?: DateTimeFilter<"UserSimulation"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserSimulation"> | Date | string | null
    timeSpent?: IntNullableFilter<"UserSimulation"> | number | null
  }

  export type SubmissionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubmissionWhereUniqueInput
    update: XOR<SubmissionUpdateWithoutUserInput, SubmissionUncheckedUpdateWithoutUserInput>
    create: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput>
  }

  export type SubmissionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubmissionWhereUniqueInput
    data: XOR<SubmissionUpdateWithoutUserInput, SubmissionUncheckedUpdateWithoutUserInput>
  }

  export type SubmissionUpdateManyWithWhereWithoutUserInput = {
    where: SubmissionScalarWhereInput
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubmissionScalarWhereInput = {
    AND?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
    OR?: SubmissionScalarWhereInput[]
    NOT?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
    id?: StringFilter<"Submission"> | string
    userId?: StringFilter<"Submission"> | string
    simulationId?: StringFilter<"Submission"> | string
    stepId?: StringFilter<"Submission"> | string
    content?: JsonFilter<"Submission">
    aiFeedback?: JsonNullableFilter<"Submission">
    score?: FloatNullableFilter<"Submission"> | number | null
    completedAt?: DateTimeFilter<"Submission"> | Date | string
    integrityFlags?: StringNullableListFilter<"Submission">
  }

  export type InvitationUpsertWithWhereUniqueWithoutCandidateInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutCandidateInput, InvitationUncheckedUpdateWithoutCandidateInput>
    create: XOR<InvitationCreateWithoutCandidateInput, InvitationUncheckedCreateWithoutCandidateInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutCandidateInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutCandidateInput, InvitationUncheckedUpdateWithoutCandidateInput>
  }

  export type InvitationUpdateManyWithWhereWithoutCandidateInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutCandidateInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    simulationId?: StringFilter<"Invitation"> | string
    candidateId?: StringNullableFilter<"Invitation"> | string | null
    email?: StringFilter<"Invitation"> | string
    token?: StringFilter<"Invitation"> | string
    status?: EnumInviteStatusFilter<"Invitation"> | $Enums.InviteStatus
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    sentAt?: DateTimeFilter<"Invitation"> | Date | string
  }

  export type UserCreateWithoutCreatedSimulationsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    simulations?: UserSimulationCreateNestedManyWithoutUserInput
    submissions?: SubmissionCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutCandidateInput
  }

  export type UserUncheckedCreateWithoutCreatedSimulationsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    simulations?: UserSimulationUncheckedCreateNestedManyWithoutUserInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type UserCreateOrConnectWithoutCreatedSimulationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSimulationsInput, UserUncheckedCreateWithoutCreatedSimulationsInput>
  }

  export type SimulationStepCreateWithoutSimulationInput = {
    id?: string
    type: $Enums.StepType
    title: string
    instructions: string
    content?: NullableJsonNullValueInput | InputJsonValue
    order: number
    aiPersona?: string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    submissions?: SubmissionCreateNestedManyWithoutStepInput
  }

  export type SimulationStepUncheckedCreateWithoutSimulationInput = {
    id?: string
    type: $Enums.StepType
    title: string
    instructions: string
    content?: NullableJsonNullValueInput | InputJsonValue
    order: number
    aiPersona?: string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStepInput
  }

  export type SimulationStepCreateOrConnectWithoutSimulationInput = {
    where: SimulationStepWhereUniqueInput
    create: XOR<SimulationStepCreateWithoutSimulationInput, SimulationStepUncheckedCreateWithoutSimulationInput>
  }

  export type SimulationStepCreateManySimulationInputEnvelope = {
    data: SimulationStepCreateManySimulationInput | SimulationStepCreateManySimulationInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutSimulationInput = {
    id?: string
    email: string
    token: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentAt?: Date | string
    candidate?: UserCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutSimulationInput = {
    id?: string
    candidateId?: string | null
    email: string
    token: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentAt?: Date | string
  }

  export type InvitationCreateOrConnectWithoutSimulationInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutSimulationInput, InvitationUncheckedCreateWithoutSimulationInput>
  }

  export type InvitationCreateManySimulationInputEnvelope = {
    data: InvitationCreateManySimulationInput | InvitationCreateManySimulationInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionCreateWithoutSimulationInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
    user: UserCreateNestedOneWithoutSubmissionsInput
    step: SimulationStepCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateWithoutSimulationInput = {
    id?: string
    userId: string
    stepId: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
  }

  export type SubmissionCreateOrConnectWithoutSimulationInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutSimulationInput, SubmissionUncheckedCreateWithoutSimulationInput>
  }

  export type SubmissionCreateManySimulationInputEnvelope = {
    data: SubmissionCreateManySimulationInput | SubmissionCreateManySimulationInput[]
    skipDuplicates?: boolean
  }

  export type RubricCreateWithoutSimulationInput = {
    id?: string
    criteria: JsonNullValueInput | InputJsonValue
    weights: JsonNullValueInput | InputJsonValue
    passingScore?: number
    createdAt?: Date | string
  }

  export type RubricUncheckedCreateWithoutSimulationInput = {
    id?: string
    criteria: JsonNullValueInput | InputJsonValue
    weights: JsonNullValueInput | InputJsonValue
    passingScore?: number
    createdAt?: Date | string
  }

  export type RubricCreateOrConnectWithoutSimulationInput = {
    where: RubricWhereUniqueInput
    create: XOR<RubricCreateWithoutSimulationInput, RubricUncheckedCreateWithoutSimulationInput>
  }

  export type UserSimulationCreateWithoutSimulationInput = {
    id?: string
    status?: $Enums.SimulationStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpent?: number | null
    user: UserCreateNestedOneWithoutSimulationsInput
  }

  export type UserSimulationUncheckedCreateWithoutSimulationInput = {
    id?: string
    userId: string
    status?: $Enums.SimulationStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type UserSimulationCreateOrConnectWithoutSimulationInput = {
    where: UserSimulationWhereUniqueInput
    create: XOR<UserSimulationCreateWithoutSimulationInput, UserSimulationUncheckedCreateWithoutSimulationInput>
  }

  export type UserSimulationCreateManySimulationInputEnvelope = {
    data: UserSimulationCreateManySimulationInput | UserSimulationCreateManySimulationInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsCreateWithoutSimulationInput = {
    id?: string
    totalCandidates: number
    avgScore: number
    completionRate: number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsUncheckedCreateWithoutSimulationInput = {
    id?: string
    totalCandidates: number
    avgScore: number
    completionRate: number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsCreateOrConnectWithoutSimulationInput = {
    where: AnalyticsWhereUniqueInput
    create: XOR<AnalyticsCreateWithoutSimulationInput, AnalyticsUncheckedCreateWithoutSimulationInput>
  }

  export type AnalyticsCreateManySimulationInputEnvelope = {
    data: AnalyticsCreateManySimulationInput | AnalyticsCreateManySimulationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedSimulationsInput = {
    update: XOR<UserUpdateWithoutCreatedSimulationsInput, UserUncheckedUpdateWithoutCreatedSimulationsInput>
    create: XOR<UserCreateWithoutCreatedSimulationsInput, UserUncheckedCreateWithoutCreatedSimulationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSimulationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSimulationsInput, UserUncheckedUpdateWithoutCreatedSimulationsInput>
  }

  export type UserUpdateWithoutCreatedSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulations?: UserSimulationUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutCandidateNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulations?: UserSimulationUncheckedUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type SimulationStepUpsertWithWhereUniqueWithoutSimulationInput = {
    where: SimulationStepWhereUniqueInput
    update: XOR<SimulationStepUpdateWithoutSimulationInput, SimulationStepUncheckedUpdateWithoutSimulationInput>
    create: XOR<SimulationStepCreateWithoutSimulationInput, SimulationStepUncheckedCreateWithoutSimulationInput>
  }

  export type SimulationStepUpdateWithWhereUniqueWithoutSimulationInput = {
    where: SimulationStepWhereUniqueInput
    data: XOR<SimulationStepUpdateWithoutSimulationInput, SimulationStepUncheckedUpdateWithoutSimulationInput>
  }

  export type SimulationStepUpdateManyWithWhereWithoutSimulationInput = {
    where: SimulationStepScalarWhereInput
    data: XOR<SimulationStepUpdateManyMutationInput, SimulationStepUncheckedUpdateManyWithoutSimulationInput>
  }

  export type SimulationStepScalarWhereInput = {
    AND?: SimulationStepScalarWhereInput | SimulationStepScalarWhereInput[]
    OR?: SimulationStepScalarWhereInput[]
    NOT?: SimulationStepScalarWhereInput | SimulationStepScalarWhereInput[]
    id?: StringFilter<"SimulationStep"> | string
    simulationId?: StringFilter<"SimulationStep"> | string
    type?: EnumStepTypeFilter<"SimulationStep"> | $Enums.StepType
    title?: StringFilter<"SimulationStep"> | string
    instructions?: StringFilter<"SimulationStep"> | string
    content?: JsonNullableFilter<"SimulationStep">
    order?: IntFilter<"SimulationStep"> | number
    aiPersona?: StringNullableFilter<"SimulationStep"> | string | null
    expectedOutput?: JsonNullableFilter<"SimulationStep">
  }

  export type InvitationUpsertWithWhereUniqueWithoutSimulationInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutSimulationInput, InvitationUncheckedUpdateWithoutSimulationInput>
    create: XOR<InvitationCreateWithoutSimulationInput, InvitationUncheckedCreateWithoutSimulationInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutSimulationInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutSimulationInput, InvitationUncheckedUpdateWithoutSimulationInput>
  }

  export type InvitationUpdateManyWithWhereWithoutSimulationInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutSimulationInput>
  }

  export type SubmissionUpsertWithWhereUniqueWithoutSimulationInput = {
    where: SubmissionWhereUniqueInput
    update: XOR<SubmissionUpdateWithoutSimulationInput, SubmissionUncheckedUpdateWithoutSimulationInput>
    create: XOR<SubmissionCreateWithoutSimulationInput, SubmissionUncheckedCreateWithoutSimulationInput>
  }

  export type SubmissionUpdateWithWhereUniqueWithoutSimulationInput = {
    where: SubmissionWhereUniqueInput
    data: XOR<SubmissionUpdateWithoutSimulationInput, SubmissionUncheckedUpdateWithoutSimulationInput>
  }

  export type SubmissionUpdateManyWithWhereWithoutSimulationInput = {
    where: SubmissionScalarWhereInput
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutSimulationInput>
  }

  export type RubricUpsertWithoutSimulationInput = {
    update: XOR<RubricUpdateWithoutSimulationInput, RubricUncheckedUpdateWithoutSimulationInput>
    create: XOR<RubricCreateWithoutSimulationInput, RubricUncheckedCreateWithoutSimulationInput>
    where?: RubricWhereInput
  }

  export type RubricUpdateToOneWithWhereWithoutSimulationInput = {
    where?: RubricWhereInput
    data: XOR<RubricUpdateWithoutSimulationInput, RubricUncheckedUpdateWithoutSimulationInput>
  }

  export type RubricUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    weights?: JsonNullValueInput | InputJsonValue
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RubricUncheckedUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    weights?: JsonNullValueInput | InputJsonValue
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimulationUpsertWithWhereUniqueWithoutSimulationInput = {
    where: UserSimulationWhereUniqueInput
    update: XOR<UserSimulationUpdateWithoutSimulationInput, UserSimulationUncheckedUpdateWithoutSimulationInput>
    create: XOR<UserSimulationCreateWithoutSimulationInput, UserSimulationUncheckedCreateWithoutSimulationInput>
  }

  export type UserSimulationUpdateWithWhereUniqueWithoutSimulationInput = {
    where: UserSimulationWhereUniqueInput
    data: XOR<UserSimulationUpdateWithoutSimulationInput, UserSimulationUncheckedUpdateWithoutSimulationInput>
  }

  export type UserSimulationUpdateManyWithWhereWithoutSimulationInput = {
    where: UserSimulationScalarWhereInput
    data: XOR<UserSimulationUpdateManyMutationInput, UserSimulationUncheckedUpdateManyWithoutSimulationInput>
  }

  export type AnalyticsUpsertWithWhereUniqueWithoutSimulationInput = {
    where: AnalyticsWhereUniqueInput
    update: XOR<AnalyticsUpdateWithoutSimulationInput, AnalyticsUncheckedUpdateWithoutSimulationInput>
    create: XOR<AnalyticsCreateWithoutSimulationInput, AnalyticsUncheckedCreateWithoutSimulationInput>
  }

  export type AnalyticsUpdateWithWhereUniqueWithoutSimulationInput = {
    where: AnalyticsWhereUniqueInput
    data: XOR<AnalyticsUpdateWithoutSimulationInput, AnalyticsUncheckedUpdateWithoutSimulationInput>
  }

  export type AnalyticsUpdateManyWithWhereWithoutSimulationInput = {
    where: AnalyticsScalarWhereInput
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyWithoutSimulationInput>
  }

  export type AnalyticsScalarWhereInput = {
    AND?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
    OR?: AnalyticsScalarWhereInput[]
    NOT?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
    id?: StringFilter<"Analytics"> | string
    simulationId?: StringFilter<"Analytics"> | string
    totalCandidates?: IntFilter<"Analytics"> | number
    avgScore?: FloatFilter<"Analytics"> | number
    completionRate?: FloatFilter<"Analytics"> | number
    diversityData?: JsonNullableFilter<"Analytics">
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
  }

  export type SimulationCreateWithoutStepsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employer: UserCreateNestedOneWithoutCreatedSimulationsInput
    invitations?: InvitationCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionCreateNestedManyWithoutSimulationInput
    rubric?: RubricCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutStepsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employerId: string
    invitations?: InvitationUncheckedCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutSimulationInput
    rubric?: RubricUncheckedCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationUncheckedCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutStepsInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutStepsInput, SimulationUncheckedCreateWithoutStepsInput>
  }

  export type SubmissionCreateWithoutStepInput = {
    id?: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
    user: UserCreateNestedOneWithoutSubmissionsInput
    simulation: SimulationCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateWithoutStepInput = {
    id?: string
    userId: string
    simulationId: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
  }

  export type SubmissionCreateOrConnectWithoutStepInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutStepInput, SubmissionUncheckedCreateWithoutStepInput>
  }

  export type SubmissionCreateManyStepInputEnvelope = {
    data: SubmissionCreateManyStepInput | SubmissionCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type SimulationUpsertWithoutStepsInput = {
    update: XOR<SimulationUpdateWithoutStepsInput, SimulationUncheckedUpdateWithoutStepsInput>
    create: XOR<SimulationCreateWithoutStepsInput, SimulationUncheckedCreateWithoutStepsInput>
    where?: SimulationWhereInput
  }

  export type SimulationUpdateToOneWithWhereWithoutStepsInput = {
    where?: SimulationWhereInput
    data: XOR<SimulationUpdateWithoutStepsInput, SimulationUncheckedUpdateWithoutStepsInput>
  }

  export type SimulationUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: UserUpdateOneRequiredWithoutCreatedSimulationsNestedInput
    invitations?: InvitationUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employerId?: StringFieldUpdateOperationsInput | string
    invitations?: InvitationUncheckedUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUncheckedUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUncheckedUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SubmissionUpsertWithWhereUniqueWithoutStepInput = {
    where: SubmissionWhereUniqueInput
    update: XOR<SubmissionUpdateWithoutStepInput, SubmissionUncheckedUpdateWithoutStepInput>
    create: XOR<SubmissionCreateWithoutStepInput, SubmissionUncheckedCreateWithoutStepInput>
  }

  export type SubmissionUpdateWithWhereUniqueWithoutStepInput = {
    where: SubmissionWhereUniqueInput
    data: XOR<SubmissionUpdateWithoutStepInput, SubmissionUncheckedUpdateWithoutStepInput>
  }

  export type SubmissionUpdateManyWithWhereWithoutStepInput = {
    where: SubmissionScalarWhereInput
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutStepInput>
  }

  export type SimulationCreateWithoutRubricInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employer: UserCreateNestedOneWithoutCreatedSimulationsInput
    steps?: SimulationStepCreateNestedManyWithoutSimulationInput
    invitations?: InvitationCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionCreateNestedManyWithoutSimulationInput
    userSimulations?: UserSimulationCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutRubricInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employerId: string
    steps?: SimulationStepUncheckedCreateNestedManyWithoutSimulationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutSimulationInput
    userSimulations?: UserSimulationUncheckedCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutRubricInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutRubricInput, SimulationUncheckedCreateWithoutRubricInput>
  }

  export type SimulationUpsertWithoutRubricInput = {
    update: XOR<SimulationUpdateWithoutRubricInput, SimulationUncheckedUpdateWithoutRubricInput>
    create: XOR<SimulationCreateWithoutRubricInput, SimulationUncheckedCreateWithoutRubricInput>
    where?: SimulationWhereInput
  }

  export type SimulationUpdateToOneWithWhereWithoutRubricInput = {
    where?: SimulationWhereInput
    data: XOR<SimulationUpdateWithoutRubricInput, SimulationUncheckedUpdateWithoutRubricInput>
  }

  export type SimulationUpdateWithoutRubricInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: UserUpdateOneRequiredWithoutCreatedSimulationsNestedInput
    steps?: SimulationStepUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUpdateManyWithoutSimulationNestedInput
    userSimulations?: UserSimulationUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutRubricInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employerId?: StringFieldUpdateOperationsInput | string
    steps?: SimulationStepUncheckedUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutSimulationNestedInput
    userSimulations?: UserSimulationUncheckedUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationCreateWithoutInvitationsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employer: UserCreateNestedOneWithoutCreatedSimulationsInput
    steps?: SimulationStepCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionCreateNestedManyWithoutSimulationInput
    rubric?: RubricCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutInvitationsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employerId: string
    steps?: SimulationStepUncheckedCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutSimulationInput
    rubric?: RubricUncheckedCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationUncheckedCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutInvitationsInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutInvitationsInput, SimulationUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutInvitationsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSimulations?: SimulationCreateNestedManyWithoutEmployerInput
    simulations?: UserSimulationCreateNestedManyWithoutUserInput
    submissions?: SubmissionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSimulations?: SimulationUncheckedCreateNestedManyWithoutEmployerInput
    simulations?: UserSimulationUncheckedCreateNestedManyWithoutUserInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
  }

  export type SimulationUpsertWithoutInvitationsInput = {
    update: XOR<SimulationUpdateWithoutInvitationsInput, SimulationUncheckedUpdateWithoutInvitationsInput>
    create: XOR<SimulationCreateWithoutInvitationsInput, SimulationUncheckedCreateWithoutInvitationsInput>
    where?: SimulationWhereInput
  }

  export type SimulationUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: SimulationWhereInput
    data: XOR<SimulationUpdateWithoutInvitationsInput, SimulationUncheckedUpdateWithoutInvitationsInput>
  }

  export type SimulationUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: UserUpdateOneRequiredWithoutCreatedSimulationsNestedInput
    steps?: SimulationStepUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employerId?: StringFieldUpdateOperationsInput | string
    steps?: SimulationStepUncheckedUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUncheckedUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUncheckedUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type UserUpsertWithoutInvitationsInput = {
    update: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSimulations?: SimulationUpdateManyWithoutEmployerNestedInput
    simulations?: UserSimulationUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSimulations?: SimulationUncheckedUpdateManyWithoutEmployerNestedInput
    simulations?: UserSimulationUncheckedUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSimulationsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSimulations?: SimulationCreateNestedManyWithoutEmployerInput
    submissions?: SubmissionCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutCandidateInput
  }

  export type UserUncheckedCreateWithoutSimulationsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSimulations?: SimulationUncheckedCreateNestedManyWithoutEmployerInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type UserCreateOrConnectWithoutSimulationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput>
  }

  export type SimulationCreateWithoutUserSimulationsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employer: UserCreateNestedOneWithoutCreatedSimulationsInput
    steps?: SimulationStepCreateNestedManyWithoutSimulationInput
    invitations?: InvitationCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionCreateNestedManyWithoutSimulationInput
    rubric?: RubricCreateNestedOneWithoutSimulationInput
    analytics?: AnalyticsCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutUserSimulationsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employerId: string
    steps?: SimulationStepUncheckedCreateNestedManyWithoutSimulationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutSimulationInput
    rubric?: RubricUncheckedCreateNestedOneWithoutSimulationInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutUserSimulationsInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutUserSimulationsInput, SimulationUncheckedCreateWithoutUserSimulationsInput>
  }

  export type UserUpsertWithoutSimulationsInput = {
    update: XOR<UserUpdateWithoutSimulationsInput, UserUncheckedUpdateWithoutSimulationsInput>
    create: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSimulationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSimulationsInput, UserUncheckedUpdateWithoutSimulationsInput>
  }

  export type UserUpdateWithoutSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSimulations?: SimulationUpdateManyWithoutEmployerNestedInput
    submissions?: SubmissionUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutCandidateNestedInput
  }

  export type UserUncheckedUpdateWithoutSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSimulations?: SimulationUncheckedUpdateManyWithoutEmployerNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type SimulationUpsertWithoutUserSimulationsInput = {
    update: XOR<SimulationUpdateWithoutUserSimulationsInput, SimulationUncheckedUpdateWithoutUserSimulationsInput>
    create: XOR<SimulationCreateWithoutUserSimulationsInput, SimulationUncheckedCreateWithoutUserSimulationsInput>
    where?: SimulationWhereInput
  }

  export type SimulationUpdateToOneWithWhereWithoutUserSimulationsInput = {
    where?: SimulationWhereInput
    data: XOR<SimulationUpdateWithoutUserSimulationsInput, SimulationUncheckedUpdateWithoutUserSimulationsInput>
  }

  export type SimulationUpdateWithoutUserSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: UserUpdateOneRequiredWithoutCreatedSimulationsNestedInput
    steps?: SimulationStepUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUpdateOneWithoutSimulationNestedInput
    analytics?: AnalyticsUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutUserSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employerId?: StringFieldUpdateOperationsInput | string
    steps?: SimulationStepUncheckedUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUncheckedUpdateOneWithoutSimulationNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type UserCreateWithoutSubmissionsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSimulations?: SimulationCreateNestedManyWithoutEmployerInput
    simulations?: UserSimulationCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutCandidateInput
  }

  export type UserUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSimulations?: SimulationUncheckedCreateNestedManyWithoutEmployerInput
    simulations?: UserSimulationUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type UserCreateOrConnectWithoutSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
  }

  export type SimulationCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employer: UserCreateNestedOneWithoutCreatedSimulationsInput
    steps?: SimulationStepCreateNestedManyWithoutSimulationInput
    invitations?: InvitationCreateNestedManyWithoutSimulationInput
    rubric?: RubricCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employerId: string
    steps?: SimulationStepUncheckedCreateNestedManyWithoutSimulationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutSimulationInput
    rubric?: RubricUncheckedCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationUncheckedCreateNestedManyWithoutSimulationInput
    analytics?: AnalyticsUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutSubmissionsInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutSubmissionsInput, SimulationUncheckedCreateWithoutSubmissionsInput>
  }

  export type SimulationStepCreateWithoutSubmissionsInput = {
    id?: string
    type: $Enums.StepType
    title: string
    instructions: string
    content?: NullableJsonNullValueInput | InputJsonValue
    order: number
    aiPersona?: string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    simulation: SimulationCreateNestedOneWithoutStepsInput
  }

  export type SimulationStepUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    simulationId: string
    type: $Enums.StepType
    title: string
    instructions: string
    content?: NullableJsonNullValueInput | InputJsonValue
    order: number
    aiPersona?: string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SimulationStepCreateOrConnectWithoutSubmissionsInput = {
    where: SimulationStepWhereUniqueInput
    create: XOR<SimulationStepCreateWithoutSubmissionsInput, SimulationStepUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserUpsertWithoutSubmissionsInput = {
    update: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSimulations?: SimulationUpdateManyWithoutEmployerNestedInput
    simulations?: UserSimulationUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutCandidateNestedInput
  }

  export type UserUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSimulations?: SimulationUncheckedUpdateManyWithoutEmployerNestedInput
    simulations?: UserSimulationUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type SimulationUpsertWithoutSubmissionsInput = {
    update: XOR<SimulationUpdateWithoutSubmissionsInput, SimulationUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<SimulationCreateWithoutSubmissionsInput, SimulationUncheckedCreateWithoutSubmissionsInput>
    where?: SimulationWhereInput
  }

  export type SimulationUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: SimulationWhereInput
    data: XOR<SimulationUpdateWithoutSubmissionsInput, SimulationUncheckedUpdateWithoutSubmissionsInput>
  }

  export type SimulationUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: UserUpdateOneRequiredWithoutCreatedSimulationsNestedInput
    steps?: SimulationStepUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employerId?: StringFieldUpdateOperationsInput | string
    steps?: SimulationStepUncheckedUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUncheckedUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUncheckedUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationStepUpsertWithoutSubmissionsInput = {
    update: XOR<SimulationStepUpdateWithoutSubmissionsInput, SimulationStepUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<SimulationStepCreateWithoutSubmissionsInput, SimulationStepUncheckedCreateWithoutSubmissionsInput>
    where?: SimulationStepWhereInput
  }

  export type SimulationStepUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: SimulationStepWhereInput
    data: XOR<SimulationStepUpdateWithoutSubmissionsInput, SimulationStepUncheckedUpdateWithoutSubmissionsInput>
  }

  export type SimulationStepUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    title?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    aiPersona?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    simulation?: SimulationUpdateOneRequiredWithoutStepsNestedInput
  }

  export type SimulationStepUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    title?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    aiPersona?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SimulationCreateWithoutAnalyticsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employer: UserCreateNestedOneWithoutCreatedSimulationsInput
    steps?: SimulationStepCreateNestedManyWithoutSimulationInput
    invitations?: InvitationCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionCreateNestedManyWithoutSimulationInput
    rubric?: RubricCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employerId: string
    steps?: SimulationStepUncheckedCreateNestedManyWithoutSimulationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutSimulationInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutSimulationInput
    rubric?: RubricUncheckedCreateNestedOneWithoutSimulationInput
    userSimulations?: UserSimulationUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutAnalyticsInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutAnalyticsInput, SimulationUncheckedCreateWithoutAnalyticsInput>
  }

  export type SimulationUpsertWithoutAnalyticsInput = {
    update: XOR<SimulationUpdateWithoutAnalyticsInput, SimulationUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<SimulationCreateWithoutAnalyticsInput, SimulationUncheckedCreateWithoutAnalyticsInput>
    where?: SimulationWhereInput
  }

  export type SimulationUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: SimulationWhereInput
    data: XOR<SimulationUpdateWithoutAnalyticsInput, SimulationUncheckedUpdateWithoutAnalyticsInput>
  }

  export type SimulationUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: UserUpdateOneRequiredWithoutCreatedSimulationsNestedInput
    steps?: SimulationStepUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employerId?: StringFieldUpdateOperationsInput | string
    steps?: SimulationStepUncheckedUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUncheckedUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationCreateManyEmployerInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    isPublished?: boolean
    isBlindMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSimulationCreateManyUserInput = {
    id?: string
    simulationId: string
    status?: $Enums.SimulationStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type SubmissionCreateManyUserInput = {
    id?: string
    simulationId: string
    stepId: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
  }

  export type InvitationCreateManyCandidateInput = {
    id?: string
    simulationId: string
    email: string
    token: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentAt?: Date | string
  }

  export type SimulationUpdateWithoutEmployerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: SimulationStepUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutEmployerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: SimulationStepUncheckedUpdateManyWithoutSimulationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutSimulationNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutSimulationNestedInput
    rubric?: RubricUncheckedUpdateOneWithoutSimulationNestedInput
    userSimulations?: UserSimulationUncheckedUpdateManyWithoutSimulationNestedInput
    analytics?: AnalyticsUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateManyWithoutEmployerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isBlindMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSimulationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    simulation?: SimulationUpdateOneRequiredWithoutUserSimulationsNestedInput
  }

  export type UserSimulationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSimulationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubmissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
    simulation?: SimulationUpdateOneRequiredWithoutSubmissionsNestedInput
    step?: SimulationStepUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
  }

  export type SubmissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
  }

  export type InvitationUpdateWithoutCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulation?: SimulationUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationStepCreateManySimulationInput = {
    id?: string
    type: $Enums.StepType
    title: string
    instructions: string
    content?: NullableJsonNullValueInput | InputJsonValue
    order: number
    aiPersona?: string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationCreateManySimulationInput = {
    id?: string
    candidateId?: string | null
    email: string
    token: string
    status?: $Enums.InviteStatus
    expiresAt: Date | string
    sentAt?: Date | string
  }

  export type SubmissionCreateManySimulationInput = {
    id?: string
    userId: string
    stepId: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
  }

  export type UserSimulationCreateManySimulationInput = {
    id?: string
    userId: string
    status?: $Enums.SimulationStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    timeSpent?: number | null
  }

  export type AnalyticsCreateManySimulationInput = {
    id?: string
    totalCandidates: number
    avgScore: number
    completionRate: number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SimulationStepUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    title?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    aiPersona?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    submissions?: SubmissionUpdateManyWithoutStepNestedInput
  }

  export type SimulationStepUncheckedUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    title?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    aiPersona?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
    submissions?: SubmissionUncheckedUpdateManyWithoutStepNestedInput
  }

  export type SimulationStepUncheckedUpdateManyWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStepTypeFieldUpdateOperationsInput | $Enums.StepType
    title?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    aiPersona?: NullableStringFieldUpdateOperationsInput | string | null
    expectedOutput?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: UserUpdateOneWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
    step?: SimulationStepUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
  }

  export type SubmissionUncheckedUpdateManyWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
  }

  export type UserSimulationUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutSimulationsNestedInput
  }

  export type UserSimulationUncheckedUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSimulationUncheckedUpdateManyWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AnalyticsUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCandidates?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCandidates?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateManyWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCandidates?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    diversityData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionCreateManyStepInput = {
    id?: string
    userId: string
    simulationId: string
    content: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    completedAt?: Date | string
    integrityFlags?: SubmissionCreateintegrityFlagsInput | string[]
  }

  export type SubmissionUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
    simulation?: SimulationUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
  }

  export type SubmissionUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    aiFeedback?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrityFlags?: SubmissionUpdateintegrityFlagsInput | string[]
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}